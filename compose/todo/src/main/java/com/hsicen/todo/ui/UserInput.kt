package com.hsicen.todo.uiimport androidx.compose.foundation.BorderStrokeimport androidx.compose.foundation.layout.PaddingValuesimport androidx.compose.foundation.layout.Rowimport androidx.compose.foundation.layout.fillMaxWidthimport androidx.compose.foundation.layout.heightimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.text.BasicTextFieldimport androidx.compose.foundation.text.KeyboardOptionsimport androidx.compose.material3.Buttonimport androidx.compose.material3.ButtonDefaultsimport androidx.compose.material3.LocalContentColorimport androidx.compose.material3.LocalTextStyleimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Surfaceimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.saveable.rememberSaveableimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.focus.onFocusChangedimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.graphics.SolidColorimport androidx.compose.ui.res.stringResourceimport androidx.compose.ui.text.input.ImeActionimport androidx.compose.ui.text.input.KeyboardTypeimport androidx.compose.ui.text.input.TextFieldValueimport androidx.compose.ui.unit.dpimport com.hsicen.todo.R@Composablefun UserInput(  onMsgSend: (String) -> Unit,  modifier: Modifier = Modifier,  resetScroll: () -> Unit = {}) {  var textState by rememberSaveable(stateSaver = TextFieldValue.Saver) {    mutableStateOf(TextFieldValue())  }  // Used to decide if the keyboard should be shown  var textFieldFocusState by remember { mutableStateOf(false) }  Surface(tonalElevation = 2.dp, contentColor = MaterialTheme.colorScheme.secondary) {    Row(      modifier = modifier        .fillMaxWidth()        .height(64.dp),    ) {      UserInputTextField(        textFieldValue = textState,        onTextChanged = { textState = it },        onTextFieldFocused = { focused ->          if (focused) {            resetScroll()          }          textFieldFocusState = focused        },        keyboardType = KeyboardType.Text,        focusState = textFieldFocusState      )      // Send button      val disabledContentColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)      val buttonColors = ButtonDefaults.buttonColors(        disabledContainerColor = Color.Transparent,        disabledContentColor = disabledContentColor      )      val border = if (textState.text.isEmpty()) {        BorderStroke(          width = 1.dp,          color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)        )      } else null      Button(        modifier = Modifier.height(36.dp),        enabled = textState.text.isNotEmpty(),        onClick = {          onMsgSend(textState.text)          textState = TextFieldValue()          resetScroll()        },        colors = buttonColors,        border = border,        contentPadding = PaddingValues(0.dp)      ) {        Text(          stringResource(id = R.string.send),          modifier = Modifier.padding(horizontal = 16.dp)        )      }    }  }}@Composableprivate fun UserInputTextField(  textFieldValue: TextFieldValue,  onTextChanged: (TextFieldValue) -> Unit,  onTextFieldFocused: (Boolean) -> Unit,  keyboardType: KeyboardType,  focusState: Boolean,  modifier: Modifier = Modifier) {  var lastFocusState by remember { mutableStateOf(false) }  BasicTextField(    value = textFieldValue,    onValueChange = { onTextChanged(it) },    modifier = modifier      .padding(start = 32.dp)      .onFocusChanged { state ->        if (lastFocusState != state.isFocused) {          onTextFieldFocused(state.isFocused)        }        lastFocusState = state.isFocused      },    keyboardOptions = KeyboardOptions(      keyboardType = keyboardType,      imeAction = ImeAction.Send    ),    maxLines = 1,    cursorBrush = SolidColor(LocalContentColor.current),    textStyle = LocalTextStyle.current.copy(color = LocalContentColor.current)  )  val disableContentColor =    MaterialTheme.colorScheme.onSurfaceVariant  if (textFieldValue.text.isEmpty() && !focusState) {    Text(      modifier = Modifier        .padding(start = 32.dp),      text = stringResource(R.string.textfield_desc),      style = MaterialTheme.typography.bodyLarge.copy(color = disableContentColor)    )  }}