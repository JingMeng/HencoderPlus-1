package com.hsicen.a04_animationimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.animation.core.InfiniteRepeatableSpecimport androidx.compose.animation.core.MutableTransitionStateimport androidx.compose.animation.core.RepeatModeimport androidx.compose.animation.core.VectorConverterimport androidx.compose.animation.core.animateDpimport androidx.compose.animation.core.animateDpAsStateimport androidx.compose.animation.core.animateValueimport androidx.compose.animation.core.rememberInfiniteTransitionimport androidx.compose.animation.core.springimport androidx.compose.animation.core.tweenimport androidx.compose.animation.core.updateTransitionimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.sizeimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.draw.clipimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.unit.Dpimport androidx.compose.ui.unit.dp/** * 作者：hsicen  2023/5/8 21:02 * 邮箱：codinghuang@163.com * 作用： * 描述：HencoderPlus *//******====== 30. Transition：多属性的状态切换 ======******//** * 作用： *  和 animateXxxAsState() ⼀样，⽤于状态切换的动画。 *  区别在于，Transition 是⾯向状态，从⽽统⼀管理多个属性。 * * 用法： *  1. 先⽤ updateTransition() 来创建（或更新） Transition 对象； *  2. 然后⽤ Transition.animateXxx() 函数来对多个属性分别设置动画 * * Label 参数： *  updateTransition() 和 animateXxx() 函数都有这个参数。 *  作⽤是给 Transition 以及属性设置字符串标记， *  ⽅便在 Android Studio 的 Animation Preview 动画预览功能中识别，便于对动画的调试。 * * transitionSpec 参数： *  由 Segment 提供的初始状态和⽬标状态来给出不同的 FiniteAnimationSpec ，因此是⼀个函数类型的参数。 * *  transitionSpec 的返回值不能是 InfiniteRepeatableSpec， *  如果想做⽆限循环的 Transition ，可以⽤ rememberInfiniteTransition()。 * * MutableTransitionState: *  可以设置初始值和⽬标值，这样就可以填⼊到 updateTransition() 中， *  来解决 Transition 的动画「不能设置初始值」的问题。 */fun ComponentActivity.composeAnimation17() {  var big by mutableStateOf(false)  setContent {    val size by animateDpAsState(if (big) 960.dp else 480.dp, label = "")    Box(      Modifier        .size(size)        .background(Color.Green)        .clickable {          big = !big        })  }}fun ComponentActivity.composeAnimation18() {  var big by mutableStateOf(false)  setContent {    val updateTransition = updateTransition(big, label = "")    val size by updateTransition.animateDp(label = "") {      if (it) 96.dp else 48.dp    }    Box(      Modifier        .size(size)        .background(Color.Green)        .clickable {          big = !big        })  }}fun ComponentActivity.composeAnimation19() {  var big by mutableStateOf(false)  setContent {    val updateTransition = updateTransition(big, label = "big")    val size by updateTransition.animateDp(label = "size") { if (it) 200.dp else 80.dp }    val corner by updateTransition.animateDp(label = "corner") { if (it) 18.dp else 0.dp }    Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {      Box(        modifier = Modifier          .size(size)          .clip(RoundedCornerShape(corner))          .background(Color.Green)          .clickable {            big = !big          }      )    }  }}fun ComponentActivity.composeAnimation20() {  var big by mutableStateOf(false)  setContent {    // val size by infiniteTransition.animateDp(label = "size") { if (it) 200.dp else 80.dp }    // val corner by infiniteTransition.animateDp(label = "corner") { if (it) 18.dp else 0.dp }    val infiniteTransition = rememberInfiniteTransition(label = "infinite")    val size by infiniteTransition.animateValue(      80.dp, 200.dp,      Dp.VectorConverter,      InfiniteRepeatableSpec(        tween(500),        RepeatMode.Reverse      ), "size"    )    val corner by infiniteTransition.animateValue(      0.dp, 100.dp,      Dp.VectorConverter,      InfiniteRepeatableSpec(        tween(500),        RepeatMode.Reverse      ), "corner"    )    Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {      Box(        modifier = Modifier          .size(size)          .clip(RoundedCornerShape(corner))          .background(Color.Green)          .clickable {            big = !big          }      )    }  }}fun ComponentActivity.composeAnimation21() {  var big by mutableStateOf(false)  setContent {    val updateTransition = updateTransition(big, label = "big")    val size by updateTransition.animateDp(      { if (!initialState && targetState) spring() else tween() },      label = "size"    ) {      if (it) 200.dp else 80.dp    }    val corner by updateTransition.animateDp(      { if (false isTransitioningTo true) spring() else tween() },      label = "corner"    ) {      if (it) 18.dp else 0.dp    }    Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {      Box(        modifier = Modifier          .size(size)          .clip(RoundedCornerShape(corner))          .background(Color.Green)          .clickable {            big = !big          }      )    }  }}fun ComponentActivity.composeAnimation22() {  var big by mutableStateOf(true)  setContent {    val state = remember { MutableTransitionState(!big) }    state.targetState = big    val updateTransition = updateTransition(state, label = "big")    val size by updateTransition.animateDp(      { if (!initialState && targetState) spring() else tween() },      label = "size"    ) {      if (it) 200.dp else 80.dp    }    val corner by updateTransition.animateDp(      { if (false isTransitioningTo true) spring() else tween() },      label = "corner"    ) {      if (it) 18.dp else 0.dp    }    Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {      Box(        modifier = Modifier          .size(size)          .clip(RoundedCornerShape(corner))          .background(Color.Green)          .clickable {            big = !big          }      )    }  }}