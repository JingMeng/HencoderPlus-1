

这个章节是说了，但是是简单的说了一下，不够深刻

https://developer.android.com/develop/ui/compose/performance/stability?hl=zh-cn


最佳实践
https://developer.android.com/develop/ui/compose/performance/bestpractices?hl=zh-cn


--------------------------------------------------------------------------------------------------------------
 使用 remember 尽可能减少开销高昂的计算

   animateColorAsState 这种state只是状态监听，并不是防止重组时候的重复计算


--------------------------------------------------------------------------------------------------------------

 使用延迟布局键  明确唯一的key，减少不必要的因素影响导致频繁的重组

--------------------------------------------------------------------------------------------------------------
尽可能延迟读取

    todo  这个没有太读懂，感觉像是状态提升
--------------------------------------------------------------------------------------------------------------


//避免向后写入
@Composable
fun BadComposable() {
    var count by remember { mutableStateOf(0) }

    // Causes recomposition on click
    Button(onClick = { count++ }, Modifier.wrapContentSize()) {
        Text("Recompose")
    }

    Text("$count")
    count++ // Backwards write, writing to state after it has been read</b>
}

 1. 这个是推荐写法

  // Causes recomposition on click
  Button(onClick = { count++ }, Modifier.wrapContentSize()) {
      Text("Recompose")
  }

 2. 这个会导致无限的重组

  count++ // Backwards write, writing to state after it has been read</b>


--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------











































































