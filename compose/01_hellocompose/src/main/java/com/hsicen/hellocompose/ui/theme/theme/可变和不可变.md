

@Stable
class WeComposeColors(
    isLight: Boolean,
    bottomBar: Color,
    background: Color,
    listItem: Color,
    divider: Color,
    chatPage: Color,
    textPrimary: Color,
    textPrimaryMe: Color,
    textSecondary: Color,
    onBackground: Color,
    icon: Color,
    iconCurrent: Color,
    badge: Color,
    onBadge: Color,
    bubbleMe: Color,
    bubbleOthers: Color,
    textFieldBackground: Color,
    more: Color,
    chatPageBgAlpha: Float,
) {
    var isLight: Boolean by mutableStateOf(isLight)
        private set

    var bottomBar: Color by mutableStateOf(bottomBar)
        private set
    var background: Color by mutableStateOf(background)
        private set
    var listItem: Color by mutableStateOf(listItem)
        private set
    var chatListDivider: Color by mutableStateOf(divider)
        private set
    var chatPage: Color by mutableStateOf(chatPage)
        private set
    var textPrimary: Color by mutableStateOf(textPrimary)
        private set
    var textPrimaryMe: Color by mutableStateOf(textPrimaryMe)
        private set
    var textSecondary: Color by mutableStateOf(textSecondary)
        private set
    var onBackground: Color by mutableStateOf(onBackground)
        private set
    var icon: Color by mutableStateOf(icon)
        private set
    var iconCurrent: Color by mutableStateOf(iconCurrent)
        private set
    var badge: Color by mutableStateOf(badge)
        private set
    var onBadge: Color by mutableStateOf(onBadge)
        private set
    var bubbleMe: Color by mutableStateOf(bubbleMe)
        private set
    var bubbleOthers: Color by mutableStateOf(bubbleOthers)
        private set
    var textFieldBackground: Color by mutableStateOf(textFieldBackground)
        private set
    var more: Color by mutableStateOf(more)
        private set
    var chatPageBgAlpha: Float by mutableStateOf(chatPageBgAlpha)
        private set
}


这些参数是可变的还是不可变的

这个问题问得非常到位 👍

我们可以从 **构造参数** 和 **类内部状态** 两个角度来分析：

---

### 🧩 一、构造参数层面：**不可变**

在这一段：

```kotlin
@Stable
class WeComposeColors(
  bottomBar: Color,
  background: Color,
  listItem: Color,
  ...
)
```

这些构造参数 (`bottomBar`, `background`, `listItem` 等)
只是构造函数的 **入参**，本身是 **不可变的局部变量**。

也就是说：

* 它们在构造函数执行期间可以被读取；
* 但一旦构造函数执行完，这些参数就超出作用域；
* 它们不是类的属性，只是用来初始化类内部真正的状态的。

---

### 🧭 二、类内部状态层面：**可变**

在类的内部，你定义了：

```kotlin
var bottomBar: Color by mutableStateOf(bottomBar)
  private set
```

这才是类真正持有的 **可观察状态（state）**。

这里：

* `var bottomBar` 是 **可变属性**；
* `by mutableStateOf()` 表示它是一个 **Compose 响应式状态**；
* `private set` 限制了外部代码不能直接修改，只能读取；
* 但类的内部可以自由修改它，例如：

  ```kotlin
  fun updateTheme(newColor: Color) {
      bottomBar = newColor
  }
  ```

当你修改这些属性时（例如 `bottomBar = Color.Red`），
Compose 会自动触发 UI 重组（recomposition）。

---

### 🧠 三、总结一下区别：

| 层级   | 名称                                     | 可变性         | 生命周期      | 用途    |
| ---- | -------------------------------------- | ----------- | --------- | ----- |
| 构造参数 | `bottomBar: Color`                     | ❌ 不可变       | 仅限构造函数    | 初始化状态 |
| 类属性  | `var bottomBar by mutableStateOf(...)` | ✅ 可变（但外部只读） | 整个对象生命周期内 | 响应式状态 |

---

### 💬 换句话说：

* 构造参数只是“初始值”；
* 类内部的 `mutableStateOf()` 属性才是真正“可变”的状态源；
* 你可以通过方法更新它，但外部无法直接改动。

---

是否需要我帮你画一张结构图，显示“构造参数 → 状态属性 → Compose 监听”的数据流？


----------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------