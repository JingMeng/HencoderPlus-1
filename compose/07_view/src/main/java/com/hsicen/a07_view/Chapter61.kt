package com.hsicen.a07_viewimport android.content.Contextimport android.util.AttributeSetimport android.view.ViewGroupimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.paddingimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Modifierimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp/******====== 60.⾃定义布局和 Layout() ======******//** * 原⽣⾃定义布局在 Compose ⾥的对应： *  1.xml 做布局 + Java 或 Kotlin 代码来增加功能性 API *      —— ⾃定义 Composable 函数 *  2.⾃定义 View ⾥⽤ onMeasure() 来做⾃定义尺⼨的测量 *      —— Modifier.layout() *  3.⾃定义 ViewGroup ⾥⽤ onMeasure() 和 onLayout() 来定制⼦ View 的测量和布局算法 *      —— Layout() （或其他）Composable 函数 * * Layout() 函数： *  1.和 Modifier.layout() 的区别：⼀个针对单个组件的尺⼨修正， *    ⼀个针对含有内部组件的组件的内部布局算法 *  2.content 参数：暴露给外部来让调⽤者填写内部的内容 *  3.measurePolicy 参数：定制布局算法 *  4.布局算法的写法：和 Modifier.layout() 道理类似， *    只是从「单个组件」变成了「多个⼦组件」，因此计算过程更加复杂 */fun ComponentActivity.composeView02() {  setContent {    ComposeLayout01()  }}@Preview@Composableprivate fun ComposeLayout01() {  Column(Modifier.padding(16.dp)) {    Text(      text = "Compose",      fontSize = 30.sp    )  }}class CustomLayout @JvmOverloads constructor(  context: Context,  attrs: AttributeSet? = null,  defStyleAttr: Int = 0) : ViewGroup(context, attrs, defStyleAttr) {  override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {    setMeasuredDimension(2, 3)  }}