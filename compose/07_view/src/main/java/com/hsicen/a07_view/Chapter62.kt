package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.BoxWithConstraintsimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.layout.SubcomposeLayoutimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp/******====== 62.自定义布局：SubcomposeLayout() ======******//** * 组合(composition)->测量(measure)->布局(layout)->绘制(draw) * LayoutNode，NodeCoordinator * * 作用：让部分的组合过程（Composition）可以被允许延后到测量和布局阶段再进行。 * * 写法： *  1.调用 SubcomposeLayout() ； *  2.使用 subcompose() 来进行实时的组合动作，生成对应的 List<Measurable> 供测量使用。 * * 案例： *  1.BoxWithConstraints() ：可以把尺寸限制（ constraints 参数）让组合代码使用到； *  2.material 包下的 Scaffold() ； *  3.LazyColumn() LazyRow() 等有动态组合需求的布局。 * * 性能： *  1.独立维护的 Slot Table，无法参与整体的重组优化 —— 弱点； *  2.重复测量也会导致强制的重组 —— 弱点； *  3.动态的组合让实际参与到界面中的节点数可以最小化 —— 优点。 */fun ComponentActivity.composeView03() {  setContent {    SubcomposeLayout01()  }}@Preview@Composableprivate fun SubcomposeLayout01() {  // SubcomposeLayout 把组合推迟到 measure 或 layout 阶段；  // 在组合阶段拿到父布局给的尺寸，可以用来做动态布局  BoxWithConstraints {    if (minWidth > 360.dp) {      Text(        text = "Compose01 layout 1",        fontSize = 30.sp,        modifier = Modifier.align(Alignment.Center)      )    } else {      Text(        text = "Compose01 layout 2",        fontSize = 30.sp,        modifier = Modifier.align(Alignment.TopStart)      )    }  }}@Preview@Composableprivate fun SubcomposeLayout02() {  SubcomposeLayout { constraints ->    // 组合    val measurables = subcompose(1) {      Text(text = "Compose02")    }    // 测量    val placeable = measurables.map {      it.measure(constraints)    }[0]    // 布局    layout(placeable.width, placeable.height) {      placeable.placeRelative(0, 0)    }  }}