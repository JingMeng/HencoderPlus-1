package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.BoxWithConstraintsimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.layout.SubcomposeLayoutimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp/******====== 63.自定义布局：LookaheadLayout() ======******//** * 组合(composition)->测量(measure)->布局(layout)->绘制(draw) * LayoutNode，NodeCoordinator * * 作用： *  1.通过提供预先测量（lookahead）的机制，来让开发者可以做【基于测量结果的过渡动画】； *  2.配合上 movableContentOf() /movableContentWithReceiverOf() ，可以做共享元素的过渡动画。 * * 写法： *  1.调用 LookaheadLayout()； *  2.对于尺寸的动画，在 intermediateLayout() 里做动画启动和动画过程中的尺寸计算这两件事； *  3.对于位置的动画，在 onPlaced() 里做动画启动，在 intermediateLayout() 里做动画过程中的尺寸计算。 * * 性能： *  1.由于存在两遍测量流程，因此性能会弱于Layout() ； *  2.由于 lookahead 过程（前瞻测量过程）在尺寸限制不变的情况下会跳过 lookahead 测量而直接返回上次的结果， *     所以实际的性能影响非常小——但还是最好只在需要的时候再用 LookaheadLayout() ， *     一般还是能用 Layout() 解决就用 Layout() */fun ComponentActivity.composeView04() {  setContent {    LookaheadLayout01()  }}@Preview@Composableprivate fun LookaheadLayout01() {  // SubcomposeLayout 把组合推迟到 measure 或 layout 阶段；  // 在组合阶段拿到父布局给的尺寸，可以用来做动态布局  BoxWithConstraints {    if (maxWidth > 360.dp) {      Text(        text = "Compose01 layout 1  max=$maxWidth  min=$minWidth",        fontSize = 30.sp,        modifier = Modifier.align(Alignment.Center)      )    } else {      Text(        text = "Compose01 layout 2  max=$maxWidth  min=$minWidth",        fontSize = 30.sp,        modifier = Modifier.align(Alignment.TopStart)      )    }  }}@Preview@Composableprivate fun LookaheadLayout02() {  SubcomposeLayout { constraints ->    // 组合    val measurables = subcompose(1) {      Text(text = "Compose02")    }    // 测量    val placeable = measurables.map {      it.measure(constraints)    }[0]    // 布局    layout(placeable.width, placeable.height) {      placeable.placeRelative(0, 0)    }  }}