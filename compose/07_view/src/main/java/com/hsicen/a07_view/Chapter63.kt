package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.animation.core.TweenSpecimport androidx.compose.animation.core.animateDpAsStateimport androidx.compose.animation.core.animateIntAsStateimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.heightimport androidx.compose.foundation.layout.widthimport androidx.compose.material.Textimport androidx.compose.runtime.*import androidx.compose.ui.ExperimentalComposeUiApiimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.layout.Layoutimport androidx.compose.ui.layout.LookaheadScopeimport androidx.compose.ui.layout.intermediateLayoutimport androidx.compose.ui.layout.layoutimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.Constraintsimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp/******====== 63.自定义布局：LookaheadLayout() ======******//** * 组合(composition) -> 测量(measure) -> 布局(layout) -> 绘制(draw) * LayoutNode，NodeCoordinator * * 作用： *  1.通过提供预先测量（lookahead）的机制，来让开发者可以做【基于测量结果的过渡动画】； *  2.配合上 movableContentOf() /movableContentWithReceiverOf() ，可以做共享元素的过渡动画。 * * 写法： *  1.调用 LookaheadLayout()； *  2.对于尺寸的动画，在 intermediateLayout() 里做动画启动和动画过程中的尺寸计算这两件事； *  3.对于位置的动画，在 onPlaced() 里做动画启动，在 intermediateLayout() 里做动画过程中的尺寸计算。 * * 性能： *  1.由于存在两遍测量流程，因此性能会弱于Layout() ； *  2.由于 lookahead 过程（前瞻测量过程）在尺寸限制不变的情况下会跳过 lookahead 测量而直接返回上次的结果， *     所以实际的性能影响非常小 —— 但还是最好只在需要的时候再用 LookaheadLayout() ， *     一般还是能用 Layout() 解决就用 Layout() */fun ComponentActivity.composeView04() {  setContent {    LookaheadLayout06()  }}@Preview@Composableprivate fun LookaheadLayout01() {  // 禁止 2 次测量：布局(Layout)中禁止，modifier中的layout不禁止(单个组件)  Layout({    Text(      text = "hsicen",      fontSize = 45.sp,      fontWeight = FontWeight.Bold,      modifier = Modifier.layout { measurable, constraints ->        // Modifier.layout: 可以多次测量        measurable.measure(constraints) // 第一次测量        val placeable = measurable.measure(constraints) // 第二次测量        layout(placeable.width, placeable.height) {          placeable.placeRelative(0, 0)        }      })  }) { measurables, constraints ->    val placeables = measurables.map {      // Layout: 禁止二次测量      it.measure(constraints) // 第一次测量      //it.measure(constraints) // 第二次测量    }    val width = placeables.maxOf { it.width }    val height = placeables.maxOf { it.height }    layout(width, height) {      placeables.forEach { it.placeRelative(0, 0) }    }  }}@OptIn(ExperimentalComposeUiApi::class)@Preview@Composableprivate fun LookaheadLayout02() {  LookaheadScope { // 包含 2 次的测量过程    println("@@@进行测量: ${System.currentTimeMillis()}")    Column {      Text(        text = "黄诗城",        modifier = Modifier          .intermediateLayout { measurable, constraints ->            val placeable = measurable.measure(              Constraints.fixed(lookaheadSize.width, lookaheadSize.height * 2)            )            layout(placeable.width, placeable.height) {              placeable.placeRelative(0, 0)            }          }          .background(Color.Gray)      )      Text(text = "hsicen", Modifier.background(Color.Yellow))    }  }}@Composable // 等同于写法2private fun LookaheadLayout03() {  println("@@@进行测量: ${System.currentTimeMillis()}")  Column {    Text(      text = "黄诗城",      modifier = Modifier        .layout { measurable, constraints ->          var placeable = measurable.measure(constraints)          placeable = measurable.measure(Constraints.fixed(placeable.width, placeable.height * 2))          layout(placeable.width, placeable.height) {            placeable.placeRelative(0, 0)          }        }        .background(Color.Gray)    )    Text(text = "hsicen", Modifier.background(Color.Yellow))  }}@Composable // 高度变化没有动画效果private fun LookaheadLayout04() {  var textHeight by remember { mutableStateOf(100.dp) }  Column {    Text(text = "黄诗城", modifier = Modifier      .background(Color.Gray)      .height(textHeight)      .width(120.dp)      .clickable {        textHeight = if (100.dp == textHeight) 200.dp else 100.dp      })    Text(text = "hsicen", modifier = Modifier.background(Color.Yellow))  }}@Composable// 高度变化有动画效果，但是刚开始渲染的时候没有动画效果private fun LookaheadLayout05() {  println("@@@进行测量: ${System.currentTimeMillis()}")  var textHeight by remember { mutableStateOf(100.dp) }  val textAnim by animateDpAsState(textHeight, label = "anim")  Column {    Text(text = "黄诗城", modifier = Modifier      .background(Color.Gray)      .height(textAnim)      .width(120.dp)      .clickable {        textHeight = if (100.dp == textHeight) 200.dp else 100.dp      })    Text(text = "hsicen", modifier = Modifier.background(Color.Yellow))  }}@OptIn(ExperimentalComposeUiApi::class)@Composable// 高度变化有动画效果，刚开始渲染的时候也有动画效果private fun LookaheadLayout06() {  var textHeight by remember { mutableStateOf(100.dp) } // 记录目标值  var textHeightPx by remember { mutableIntStateOf(0) } // 动画目标值  val textAnim by animateIntAsState(textHeightPx, TweenSpec(1000), label = "anim")  Column {    LookaheadScope {      Text(text = "黄诗城", modifier = Modifier        .intermediateLayout { measurable, _ ->          // 测量阶段          textHeightPx = lookaheadSize.height          // do animation 动画改变高度          val placeable = measurable.measure(Constraints.fixed(lookaheadSize.width, textAnim))          layout(placeable.width, placeable.height) {            placeable.placeRelative(0, 0)          }        }        .background(Color.Gray)        .width(120.dp)        .height(textHeight)        .clickable {          textHeight = if (100.dp == textHeight) 200.dp else 100.dp        })    }    Text(text = "hsicen", modifier = Modifier.background(Color.Yellow))  }}