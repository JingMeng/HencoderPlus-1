package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.ExperimentalFoundationApiimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.gestures.*import androidx.compose.foundation.interaction.MutableInteractionSourceimport androidx.compose.foundation.interaction.collectIsDraggedAsStateimport androidx.compose.foundation.layout.heightimport androidx.compose.foundation.layout.offsetimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.foundation.lazy.rememberLazyListStateimport androidx.compose.material.Buttonimport androidx.compose.material.Textimport androidx.compose.runtime.*import androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.input.pointer.pointerInputimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.IntOffsetimport androidx.compose.ui.unit.dpimport kotlinx.coroutines.launchimport kotlin.math.roundToInt/******====== 64.自定义触摸和一维滑动监测 ======******//** * Modifier.draggable() *   1.一维滑动监测用的 Modifier *   2.DraggableState 的参数里填写每一个滑动瞬间的算法 *   3.如果操作界面滑动，要修改的是依赖的状态的值，例如 offset() 里所依赖的偏移量 *   4.interactionSource 参数可以用于手指拖移状态的监听 * * Modifier.scrollable() *   1.也是一维滑动监测用的 Modifier ； *   2.基于 draggable() ，但增加了嵌套滑动、惯性滑动和触边效果的支持， *     专注于滑动布局的应用场景，具体的用法和 draggable() 基本一致 */fun ComponentActivity.composeView05() {  setContent {    TouchAndScroll03()  }}@Preview@Composable // 高度自定义触摸反馈private fun TouchAndScroll01() {  Modifier.pointerInput(Unit) {    awaitEachGesture {      val event = awaitPointerEvent()    }  }}@Preview@Composable // Modifier.scrollable()private fun TouchAndScroll02() {  // 一维拖拽和滑动处理  val listState = rememberLazyListState()  LazyColumn(state = listState) {    items(200) {      Text(        text = "Hello Compose $it",        Modifier          .height(48.dp)          .padding(top = 16.dp, start = 16.dp)          .background(Color.LightGray)      )    }  }  val scope = rememberCoroutineScope()  Button(onClick = {    scope.launch {      listState.scrollToItem(20)    }  }) {    Text(text = "移动位置")  }}@Preview@Composable // Modifier.draggable()private fun TouchAndScroll03() {  // 拖动状态监听  val mis = remember { MutableInteractionSource() }  var offsetY by remember { mutableFloatStateOf(0f) }  Text(    text = "Hello Compose : Drag",    Modifier      .padding(32.dp)      .background(Color.LightGray)      .padding(16.dp)      .offset { IntOffset(0, offsetY.roundToInt()) }      .draggable(        // 拖动位置回调        rememberDraggableState {          offsetY += it          println("@@@ 移动了：$it 像素")        },        Orientation.Vertical,        //        interactionSource = mis,      )  )  val isDrag by mis.collectIsDraggedAsState()  Text(if (isDrag) "拖动中" else "静止")}@OptIn(ExperimentalFoundationApi::class)@Composable // Modifier.scrollable()private fun TouchAndScroll04() {  // Modifier.verticalScroll() ==  ScrollView  // Modifier.horizontalScroll() == HorizontalScrollView  // Modifier.scrollable() 滑动监测  // 惯性滑动  // 嵌套滑动  // 滑动触边效  Modifier.scrollable(    rememberScrollableState {      println("滚动了：$it 个像素")      it    },    Orientation.Horizontal,    overscrollEffect = ScrollableDefaults.overscrollEffect(),    flingBehavior = ScrollableDefaults.flingBehavior()  )  // Modifier.swipeable()  // SwipeToDismiss(state =, background =) {}}