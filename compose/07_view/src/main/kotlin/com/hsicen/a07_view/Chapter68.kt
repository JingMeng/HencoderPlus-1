package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.gestures.awaitEachGestureimport androidx.compose.foundation.gestures.awaitFirstDownimport androidx.compose.foundation.layout.sizeimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.input.pointer.PointerEventTypeimport androidx.compose.ui.input.pointer.pointerInputimport androidx.compose.ui.unit.dp/******====== 68.⾃定义触摸：最底层的 100% ⾃定义触摸算法 ======******//** * 基本写法： *  1.Modifier.pointerInput() *  2.awaitEachGesture() *  3.⾥⾯⽤ awaitPointerEvent() 获取和处理事件，定制⾃⼰的算法。 * * 关于触摸事件： *  1.按下和抬起事件跟 View 系统的不同：Press 和 Release 包含了任何触摸点的按下和抬起， *    所以对于「第⼀次按下」和「最后⼀次抬起」，要做额外的附加条件来判断（例如「只有⼀个触摸点存在」）。 *  2.触摸事件是「有触摸点发⽣了事件」，⽽不是「某个触摸点发⽣了事件」，因此 PointerEvent 的 changes 是个数组。 * * 消费、拦截和取消： *  1.Compose ⾥是三遍事件传递的流程，⽽不是 Android 原⽣的两遍。 *  2.Compose 不再有「事件拦截」的概念，⽽是在任何节点都可以消费，并可以被后续的节点感知到「已消费」的事实。 *  3.原则： *      1.使⽤触摸事件之后，把它消费掉（如果有合适的理由，可以例外）； *      2.使⽤触摸事件之前，先看它有没有消费，没有消费过再触发业务逻辑（如果有合适的理由，可以例外）； *      3.另外：记得考虑⼀下要不要在第三流程⾥检查事件是否被⽗组件消费过，从⽽取消⼿势。 * * MotionEvent: *  ACTION_DOWN *  ACTION_POINTER_DOWN *  ACTION_MOVE *  ACTION_POINTER_UP *  ACTION_UP * * PointerEvent: *  ACTION_PRESS *  ACTION_MOVE *  ACTION_RELEASE */fun ComponentActivity.composeView09() {  setContent {    CustomTouch02()  }}@Composableprivate fun CustomTouch01() {  Text(text = "hsicen",    modifier = Modifier      .size(100.dp)      .background(Color.Gray)      .pointerInput(Unit) {        awaitEachGesture {          var event = awaitPointerEvent()          println("@@@接收到触摸事件：${event.type}")          event = awaitPointerEvent()          println("@@@接收到触摸事件：${event.type}")          event = awaitPointerEvent()          println("@@@接收到触摸事件：${event.type}")        }      })}@Composableprivate fun CustomTouch02() {  Text(text = "hsicen",    modifier = Modifier      .size(100.dp)      .background(Color.Gray)      .clickable { }      .hsicenClick03 {        println("@@@点击事件")      })}@Composableprivate fun Modifier.hsicenClick01(onClick: () -> Unit) =  this.pointerInput(Unit) {    awaitPointerEventScope {      while (true) {        val event = awaitPointerEvent()        if (event.type == PointerEventType.Release) {          onClick()        }      }    }  }@Composableprivate fun Modifier.hsicenClick02(onClick: () -> Unit) =  this.pointerInput(Unit) {    awaitPointerEventScope {      while (true) {        val down = awaitPointerEvent()        while (true) {          val event = awaitPointerEvent()          when (event.type) {            PointerEventType.Move -> {              val pos = event.changes[0].position              if (pos.x < 0                || pos.x > size.width                || pos.y < 0                || pos.y > size.height              ) {                println("@@@点击取消")                break              }            }            PointerEventType.Release -> {              onClick()              break            }          }        }      }    }  }@Composableprivate fun Modifier.hsicenClick03(onClick: () -> Unit) =  this.pointerInput(Unit) {    awaitEachGesture {      val firstDown = awaitFirstDown()      while (true) {        val event = awaitPointerEvent()        // offset = event.calculatePan() 计算位移中心点        // scale = event.calculateZoom() 计算缩放中心点        when (event.type) {          PointerEventType.Move -> {            val pos = event.changes[0].position            if (pos.x < 0              || pos.x > size.width              || pos.y < 0              || pos.y > size.height            ) {              println("@@@点击取消")              break            }          }          PointerEventType.Release -> {            // last finger up            if (event.changes.size == 1) {              onClick()              break            }          }        }      }      // 使用完，消费掉      // 先检查有没有被消费    }  }