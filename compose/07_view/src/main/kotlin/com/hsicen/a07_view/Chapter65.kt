package com.hsicen.a07_viewimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.gestures.Orientationimport androidx.compose.foundation.gestures.draggableimport androidx.compose.foundation.gestures.rememberDraggableStateimport androidx.compose.foundation.layout.*import androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.material.Textimport androidx.compose.runtime.*import androidx.compose.ui.Modifierimport androidx.compose.ui.geometry.Offsetimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.input.nestedscroll.NestedScrollConnectionimport androidx.compose.ui.input.nestedscroll.NestedScrollDispatcherimport androidx.compose.ui.input.nestedscroll.NestedScrollSourceimport androidx.compose.ui.input.nestedscroll.nestedScrollimport androidx.compose.ui.text.style.TextAlignimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.IntOffsetimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp/******====== 65.嵌套滑动和 nestedScroll() ======******//** * 整体逻辑 *   1.子组件在滑动前，询问父组件要不要「优先滑动」； *   2.子组件在滑动时，要先减去父组件消费的距离； *   3.子组件在滑动后，再询问父组件要不要「消费剩余的滑动距离」 * *   nestedScroll()：会给嵌套滑动链条里增加一个节点，自动把下游的嵌套滑动通知传递到上游 * * 参数：connection *    提供处理下游嵌套滑动回调的处理逻辑 * * 参数：dispatcher *    提供向上游通报自己直接的触摸拖动导致的嵌套滑动事件。 *    可以为空，因为有些场景下会有父组件仅仅需要被动参与嵌套滑动，却不需要被用户直接触摸 */fun ComponentActivity.composeView06() {  setContent {    NestedScroll02()  }}@Preview@Composableprivate fun NestedScroll01() {  LazyColumn(Modifier.fillMaxSize()) {    item {      LazyColumn(        Modifier          .fillMaxWidth()          .height(250.dp)          .background(Color.Red)      ) {        item {          repeat(8) {            Text(              text = "第一部分：$it",              fontSize = 30.sp,              textAlign = TextAlign.Center,              modifier = Modifier                .padding(10.dp)                .fillMaxWidth()            )          }        }      }      repeat(20) {        Text(          text = "第二部分：$it",          fontSize = 30.sp,          textAlign = TextAlign.Center,          modifier = Modifier            .padding(10.dp)            .fillMaxWidth()        )      }    }  }}@Composableprivate fun NestedScroll02() {  var offsetY by remember { mutableFloatStateOf(0f) }  val dispatcher = remember { NestedScrollDispatcher() }  val connection = remember {    object : NestedScrollConnection {      // call before child scroll      override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {        return super.onPreScroll(available, source)      }      // call after child scrolled      override fun onPostScroll(        consumed: Offset,        available: Offset,        source: NestedScrollSource      ): Offset {        offsetY += available.y        return available      }    }  }  Column(    Modifier      .fillMaxWidth()      .offset { IntOffset(0, offsetY.toInt()) }      .padding(16.dp)      .draggable(rememberDraggableState {        // before scroll to call parent        val consumed = dispatcher.dispatchPreScroll(Offset(0f, it), NestedScrollSource.Drag)        // self scroll        offsetY += it - consumed.y        // after scroll to call parent        dispatcher.dispatchPostScroll(Offset(0f, it), Offset(0f, 0f), NestedScrollSource.Drag)      }, Orientation.Vertical)      .nestedScroll(connection, dispatcher)  ) {    repeat(10) {      Text(        text = "这是第 $it 项数据",        fontSize = 16.sp,        textAlign = TextAlign.Center,        modifier = Modifier          .fillMaxWidth()          .padding(16.dp)      )    }    LazyColumn(Modifier.height(100.dp)) {      items(10) {        Text(text = "内部第 $it 项数据", fontSize = 16.sp)      }    }  }}