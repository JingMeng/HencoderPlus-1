package com.hsicen.a06_coroutineimport android.graphics.Pointimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.paddingimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.DisposableEffectimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.collectAsStateimport androidx.compose.runtime.getValueimport androidx.compose.runtime.livedata.observeAsStateimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.produceStateimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.platform.LocalLifecycleOwnerimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.Observerimport kotlinx.coroutines.flow.MutableStateFlow/******====== 58.从 produceState() 说起：协程（和其他）状态向 Compose 状态的转换 ======******//** * ⽤ DisposableEffect() 转换⾮协程的状态： *  1.在 DisposableEffect() ⾥订阅状态，并把更新的值赋值到 Compose 的 State ； *  2.利⽤ onDispose() 来取消订阅。 * * ⽤ LaunchedEffect() 转换协程的状态： *  1.在 LaunchedEffect() ⾥订阅协程的 Flow （不是 Flow 也⾏，例如单次的⽹络请求挂起函数）； *  2.因为协程会⾃动取消， Flow.collect() 也会⾃动取消，所以不⽤⼿动取消订阅； *  3.如果利⽤ LaunchedEffect() 来订阅⾮协程的状态（⽐较少⻅）， *    需要⽤ awaitDispose() 来设置取消监听，⼿动取消订阅；这也有防⽌协程提早结束的作⽤。 * * produceState()： *  1.其实只是⼀个对 LaunchedEffect() 这种状态转换的写法的包装。 */fun ComponentActivity.composeCoroutine06() {  setContent {    ProduceState01()  }}@Composableprivate fun ProduceState01() {  val posFlow = MutableStateFlow(Point(0, 0))  // 方式1  val position = produceState(Point(0, 0)) {    posFlow.collect { newPos ->      value = newPos    }    // 挂起协程，直到协程结束，然后调用 lambda 表达式    awaitDispose {}  }  // 方式2  val stateFromFlow = posFlow.collectAsState()  Box(modifier = Modifier.padding(16.dp)) {    Text(      text = "Position=${position.value}",      fontSize = 30.sp    )  }}@Composableprivate fun ProduceState05() {  val posLiveData = MutableLiveData<Point>()  val lifecycleOwner = LocalLifecycleOwner.current  val position = produceState(Point(0, 0)) {    val observer = Observer<Point> { newLocation ->      value = newLocation    }    posLiveData.observe(lifecycleOwner, observer)    // 挂起协程，直到协程结束，然后调用 lambda 表达式    awaitDispose {      posLiveData.removeObserver(observer)    }  }  Box(modifier = Modifier.padding(16.dp)) {    Text(      text = "Position=${position.value}",      fontSize = 30.sp    )  }}@Composableprivate fun ProduceState02() {  var position by remember { mutableStateOf(Point(0, 0)) }  val locator by remember { mutableStateOf(Locator()) }  Box(modifier = Modifier.padding(16.dp)) {    Text(      text = "Position=$position",      fontSize = 30.sp    )    DisposableEffect(Unit) {      val observer = LocatorObserver { newLocation ->        position = newLocation      }      locator.register(observer)      onDispose {        locator.unregister(observer)      }    }  }}@Composableprivate fun ProduceState03() {  var position by remember { mutableStateOf(Point(0, 0)) }  val posLiveData = MutableLiveData<Point>()  Box(modifier = Modifier.padding(16.dp)) {    Text(      text = "Position=$position",      fontSize = 30.sp    )    // 方式1    val lifecycleOwner = LocalLifecycleOwner.current    DisposableEffect(Unit) {      val observer = Observer<Point?> { newLocation ->        position = newLocation ?: position      }      posLiveData.observe(lifecycleOwner, observer)      onDispose {        posLiveData.removeObserver(observer)      }    }    // 方式2    val stateFromLiveData = posLiveData.observeAsState()  }}@Composableprivate fun ProduceState04() {  var position by remember { mutableStateOf(Point(0, 0)) }  val posFlow = MutableStateFlow(position)  Box(modifier = Modifier.padding(16.dp)) {    Text(      text = "Position=$position",      fontSize = 30.sp    )    LaunchedEffect(Unit) {      posFlow.collect { newLocation ->        position = newLocation      }    }  }}class Locator {  private val mObserver = mutableListOf<LocatorObserver>()  private var mLocation = Point(0, 0)  fun register(observer: LocatorObserver) {    if (!mObserver.contains(observer)) {      mObserver.add(observer)    }  }  fun unregister(observer: LocatorObserver) {    mObserver.remove(observer)  }  fun notify(observer: LocatorObserver) {    observer.onLocation(mLocation)  }}fun interface LocatorObserver {  fun onLocation(newLocation: Point)}