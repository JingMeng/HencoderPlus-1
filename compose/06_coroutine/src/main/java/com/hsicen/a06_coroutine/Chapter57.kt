package com.hsicen.a06_coroutineimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.paddingimport androidx.compose.material3.Buttonimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.rememberCoroutineScopeimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport kotlinx.coroutines.delayimport kotlinx.coroutines.launch/******====== 56.rememberCoroutineScope() ======******//** * LaunchedEffect() 所解决的问题： *  1.提供和 Composable 组件所匹配的 CoroutineScope ； *  2.⽤ remember() 来确保 Composable 函数被重复调⽤的时候，不会导致反复重启协程。 * * rememberCoroutineScope() 所解决的问题： *  1.不在 Composable 函数⾥启动协程，但却需要绑定 Composable 函数的⽣命周期。 * * 只有一半需求的场景： CoroutineScope 或 remember */fun ComponentActivity.composeCoroutine05() {  setContent {    CoroutineScope02()  }}@Composableprivate fun CoroutineScope01() {  var show by remember { mutableStateOf(true) }  Button(modifier = Modifier.padding(16.dp), onClick = {    show = !show  }) {    Text(      text = "Compose",      fontSize = 30.sp    )    if (show) {      Text(text = "Hello")    }  }  // 方式1  val scope = rememberCoroutineScope()  remember {    scope.launch {      // start your coroutine code here.      println("@@@ code form rememberCoroutineScope.")    }  }  // 方式2  LaunchedEffect(Unit) {    // start your coroutine code here.    println("@@@ code form LaunchedEffect.")  }}@Composableprivate fun CoroutineScope02() {  val scope = rememberCoroutineScope()  Button(onClick = {    scope.launch {      delay(3000)      println("@@@ Hello from coroutine.")    }  }) {    Text(text = "Click start coroutine.")  }}