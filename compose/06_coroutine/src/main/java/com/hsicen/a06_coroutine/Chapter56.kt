package com.hsicen.a06_coroutineimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.compose.foundation.layout.paddingimport androidx.compose.material3.Buttonimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.DisposableEffectimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.SideEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.rememberUpdatedStateimport androidx.compose.runtime.setValueimport androidx.compose.ui.Modifierimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport kotlinx.coroutines.delay/******====== 56.rememberUpdatedState() ======******//** * 适⽤场景: *  1.当 LaunchedEffect() 或者 DisposableEffect() 中有「稍后使⽤」的外部依赖， *   并且依赖是由函数参数提供⽽导致失去了跨越多次重组的能⼒的时候， *   需要在函数内⽤ remember()结合赋值⾏为来重新建⽴变量的缓存能⼒（跨越多次重组的能⼒）。 *  2.rememberUpdatedState() 把这种⼯作整合进了⼀个函数⾥。 * * 所以，更重要的不是 rememberUpdatedState() 的原理，⽽是从对它所⾯向的问题的理解， * 来了解它适⽤的场景。 */fun ComponentActivity.composeCoroutine04() {  setContent {    UpdatedState01()  }}@Composableprivate fun UpdatedState01() {  var msgStr by remember { mutableStateOf("hsicen") }  Text(text = msgStr)  var show by remember { mutableStateOf(true) }  Button(modifier = Modifier.padding(16.dp), onClick = {    show = !show  }) {    Text(      text = "Compose",      fontSize = 30.sp    )    if (show) Text(text = "Hello")    SideEffect {      println("@@@ Enter SideEffect.")    }    var user = ???    CustomDisposableEffect(user)    var welcome by remember { mutableStateOf("欢迎光临！") }    // a special style of disposable effect    CustomLaunchedEffect04(welcome)    Button(onClick = {      welcome = "欢迎个屁！"    }) {      Text(text = welcome)    }  }}@Composableprivate fun CustomDisposableEffect(xxx: User) {  val newUser by rememberUpdatedState(xxx)  DisposableEffect(Unit) {// 会因 key 发生改变而重新执行    subscriber.subscribe(newUser)    onDispose {      xxx.unsubscribe()    }  }}@Composableprivate fun CustomLaunchedEffect01(welcome: String) {  // welcome 被截断，其实改变后的值已经传进来了  LaunchedEffect(Unit) {    // 在 Composable 组件显示完成之后启动协程    // 在 Key 参数发生改变之后重启协程    println("@@@ Enter LaunchedEffect.")    delay(3000)    println("@@@ $welcome.")  }}@Composableprivate fun CustomLaunchedEffect02(welcome: String) {  LaunchedEffect(welcome) {    // 在 Composable 组件显示完成之后启动协程    // 在 Key 参数发生改变之后重启协程    println("@@@ Enter LaunchedEffect.")    delay(3000)    println("@@@ $welcome.")  }}@Composableprivate fun CustomLaunchedEffect03(welcome: String) {  var newWelcome by remember { mutableStateOf(welcome) }  newWelcome = welcome  LaunchedEffect(Unit) {    // 在 Composable 组件显示完成之后启动协程    // 在 Key 参数发生改变之后重启协程    println("@@@ Enter LaunchedEffect.")    delay(3000)    println("@@@ $newWelcome.")  }}@Composableprivate fun CustomLaunchedEffect04(welcome: String) {  // var newWelcome by remember { mutableStateOf(welcome) }  // newWelcome = welcome  val newWelcome by rememberUpdatedState(welcome)  LaunchedEffect(Unit) {    // 在 Composable 组件显示完成之后启动协程    // 在 Key 参数发生改变之后重启协程    println("@@@ Enter LaunchedEffect.")    delay(3000)    println("@@@ $newWelcome.")  }}