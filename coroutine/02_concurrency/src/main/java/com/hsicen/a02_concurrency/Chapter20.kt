package com.hsicen.a02_concurrencyimport kotlinx.coroutines.*import kotlin.coroutines.EmptyCoroutineContext/******====== 20.协程的结构化异常管理 ======******//** * 协程的异常： *  1.异常捕获(try-catch)不能穿透协程，必须在协程里进行捕获，父协程捕获后，在子协程里也需要捕获 *  2.父协程异常，子协程也会被取消；子协程异常，父协程也会被取消 *  3.协程的取消（cancel/CancellationException） 是向内进行的，单向流，只会取消自己和自己内部的子协程 *  4.协程的异常是双向的，会取消自己和自己内部的子协程以及父协程和兄弟协程 */fun main(): Unit = runBlocking {  test3()  delay(10000)}// 子协程异常导致父协程取消private suspend fun test3() {  val scope = CoroutineScope(EmptyCoroutineContext)  var childJob: Job? = null  val parentJob = scope.launch {    println("Parent start.")    childJob = launch {      launch {        println("Child1 start")        delay(3000)        println("Child1 end")      }      println("Child start")      delay(1000)      throw RuntimeException("run error.")    }    delay(3000)    println("Parent end")  }  delay(500)  println("isActive: parent=${parentJob.isActive} child=${childJob?.isActive}")  println("isCancel: parent=${parentJob.isCancelled} child=${childJob?.isCancelled}")  delay(1000)  println("isActive: parent=${parentJob.isActive} child=${childJob?.isActive}")  println("isCancel: parent=${parentJob.isCancelled} child=${childJob?.isCancelled}")}// 父协程异常导致子协程取消private suspend fun test2() {  val scope = CoroutineScope(EmptyCoroutineContext)  var childJob: Job? = null  val parentJob = scope.launch {    println("Parent start.")    childJob = launch {      println("Child start")      delay(3000)      println("Child end")    }    delay(1000)    throw RuntimeException("run error.")  }  delay(500)  println("isActive: parent=${parentJob.isActive} child=${childJob?.isActive}")  println("isCancel: parent=${parentJob.isCancelled} child=${childJob?.isCancelled}")  delay(1000)  println("isActive: parent=${parentJob.isActive} child=${childJob?.isActive}")  println("isCancel: parent=${parentJob.isCancelled} child=${childJob?.isCancelled}")}// 异常捕获(try-catch)不能穿透协程private fun test1() {  val scope = CoroutineScope(EmptyCoroutineContext)  var childJob: Job? = null  val parentJob = scope.launch {    try {      childJob = launch {        try {          throw RuntimeException("run error.")        } catch (e: RuntimeException) {          throw CancellationException()        }      }      throw IllegalArgumentException("error root cause.")    } catch (e: IllegalArgumentException) {      throw CancellationException()    }  }}