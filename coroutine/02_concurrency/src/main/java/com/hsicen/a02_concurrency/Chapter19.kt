package com.hsicen.a02_concurrencyimport kotlinx.coroutines.*import kotlin.coroutines.EmptyCoroutineContextimport kotlin.coroutines.cancellation.CancellationException/******====== 19.不配合取消:NoCancellable ======******//** * NonCancellable： *  1.不能被父协程取消，但是可以被自己取消 *  2.如果使用自己的Job，则不受父协程控制，但是可以被自己取消 *  3.实现了Job接口，重写了 cancel 方法 *  4.不让内部协程被外部取消 * * 不能被取消的工作场景： *  1.收尾工作 *  2.数据完整性的读写工作 *  3.数据上报工作等不相关的工作 */fun main(): Unit = runBlocking {  val scope = CoroutineScope(EmptyCoroutineContext)  val newParent = Job()  val parentJob: Job?  var childJob: Job? = null  var childJob2: Job? = null  parentJob = scope.launch {    childJob = launch(NonCancellable) {      println("child start.")      delay(3000)      println("child end.")    }    childJob2 = launch(newParent) {      if (isActive.not()) {        withContext(NonCancellable) {          // clean work.          println("childJob2 clean work end.")        }        throw CancellationException()      }      println("child2 start.")      delay(3000)      println("child2 end.")    }    println("parent start.")    delay(3000)    println("parent end.")  }  delay(1500)  childJob2?.cancel()  delay(10000)}// 不支持取消的工作suspend fun writeInfo() = withContext(Dispatchers.IO + NonCancellable) {  // write to file  // read from database  // do something  // write to file}