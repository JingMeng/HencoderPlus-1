package com.hsicen.a02_concurrencyimport kotlinx.coroutines.*import kotlin.coroutines.EmptyCoroutineContext/******====== 24.SupervisorJob ======******//** * SupervisorJob：(可以结构化取消子协程 而 不会因为子协程的异常而被取消) *  1.当子协程因为异常而取消时，父协程不会被取消 *  2.当父协程取消时，子协程也会结构性的取消 *  3.作为中间的父协程时会直接把子协程的异常给处理了，不会向上传递，不会取消父协程和兄弟协程 */fun main(): Unit = runBlocking {  test3()  delay(3000)}private suspend fun test1() {  val job = SupervisorJob()  val exHandler = CoroutineExceptionHandler { _, throwable ->    println("root catch error: $throwable")  }  val scope = CoroutineScope(job)  scope.launch {    throw RuntimeException("child run error")  }  delay(100)  println("Parent isCanceled: ${job.isCancelled}")}private suspend fun test2() {  val job = SupervisorJob()  val exHandler = CoroutineExceptionHandler { _, throwable ->    println("root catch error: $throwable")  }  val scope = CoroutineScope(job)  scope.launch {    println("parent start")    launch {      println("child start")      delay(200)      println("child end")    }    delay(200)    println("parent end")  }  delay(100)  job.cancel()  println("Parent isCanceled: ${job.isCancelled}")}private suspend fun test3() {  val scope = CoroutineScope(EmptyCoroutineContext)  var childJob: Job? = null  scope.launch {    println("parent start")    childJob = launch(SupervisorJob(coroutineContext.job)) {      println("child start")      launch {        println("child1 start")        throw RuntimeException("child1 run error")      }      try {        delay(400)        println("child end")      } catch (e: CancellationException) {        println("child catch error: $e")      }    }    launch {      println("child2 start")      delay(200)      println("child2 end")    }    delay(200)    println("parent end")  }  delay(300)  println("childJob isCanceled: ${childJob?.isCancelled}")}