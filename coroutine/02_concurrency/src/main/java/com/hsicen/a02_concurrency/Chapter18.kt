package com.hsicen.a02_concurrencyimport kotlinx.coroutines.*import kotlin.coroutines.EmptyCoroutineContextimport kotlin.time.measureTime/******====== 18.线程的结构化取消 ======******//** * 父子协程具有关联关系，当父协程被取消时，子协程也会被取消。 * ·如果协程内部有挂起函数(delay,await)，协程取消时会抛异常 CancellationException * ·cancel时会将 isActive 置为 false * ·会依次调用子协程的 cancel * ·如果没有挂起函数或检查点，父协程 cancel 时，子协程可能会一直执行 * * 协程的取消： *  1.父协程调用cancel *  2.自己内部抛出CancellationException * * 协程取消的工作： *  1.cancel 时将 isActive 置为 false *  2.调用子协程的 cancel *  3.代码里的检查点 isActive，发现取消时抛出 CancellationException * * 子协程如何拒绝取消 *  1.只能从取消工作的第三点开始 *  2.所以子协程不能拒绝取消 或者说 只能拒绝一点点 *  3.不推荐打乱协程的结构化取消逻辑 * * zi'ce */fun main(): Unit = runBlocking {  val scope = CoroutineScope(EmptyCoroutineContext)  val parentJob = scope.launch(Dispatchers.Default) {    val childJob = launch {      try {        println("child job started.")        delay(2000)        // Thread.sleep(4000)      } catch (_: CancellationException) {      }      println("Hello from child.")    }  }  delay(1000)  parentJob.cancel()  measureTime {    parentJob.join()  }.also {    println("parentJob join cost time: $it")  }  delay(10000)}