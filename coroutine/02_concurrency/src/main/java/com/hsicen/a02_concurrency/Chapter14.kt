package com.hsicen.a02_concurrencyimport kotlinx.coroutines.*import kotlin.coroutines.EmptyCoroutineContext/******====== 14.父子协程 以及协程间的并行和等待 ======******//** * 结构化并发(结束)： *  1.父协程会等待子协程执行完成再结束 *  2.调用job.join()可以等待job执行完成后再执行后续代码 */@OptIn(ExperimentalCoroutinesApi::class)fun main() = runBlocking {  val scope = CoroutineScope(EmptyCoroutineContext) // 会创建一个Job  var job: Job? = null  var innerJob: Job? = null  var innerJob2: Job? = null  var innerJob3: Job? = null  job = scope.launch {    innerJob = launch {      delay(500)    }    innerJob2 = scope.launch {      delay(500)    }    innerJob3 = launch(job?.get(Job)!!) {      delay(500)    }  }  // job 与 innerJob 是父子关系  val children = job.children  println("@@@ childrenCount: ${children.count()}")  println("@@@ innerJob == children.first(): ${children.firstOrNull() === innerJob}")  println("@@@ innerJob.parent == job: ${innerJob?.parent === job}")  // job 与 innerJob2 是兄弟关系  println("@@@ innerJob2 == job: ${innerJob2 === job}")  println("@@@ job.parent == innerJob2.parent: ${job.parent === innerJob2?.parent}")  // innerJob 与 innerJob3 是兄弟关系  println("@@@ innerJob.parent == innerJob3.parent: ${innerJob?.parent === innerJob3?.parent}")}