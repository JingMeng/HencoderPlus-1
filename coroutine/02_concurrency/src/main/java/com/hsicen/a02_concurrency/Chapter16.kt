package com.hsicen.a02_concurrencyimport kotlinx.coroutines.runBlocking/******====== 16.线程的交互式结束：interrupt() ======******//** * Thread.interrupt: *  1.不会强制结束线程，只是标记线程需要结束 *  2.由开发者查询该标记，结束线程任务 *  3.在耗时函数之前检查，早检查，早结束 *  4.isInterrupted 不会重置标记 *  5.interrupted() 会重置标记 */fun main() = runBlocking {  val thread = object : Thread() {    override fun run() {      println("Thread: I'm running in ${currentThread().name}")      var count = 0      while (true) {        try {          sleep(300)        } catch (e: InterruptedException) {          // clean 会重置中断状态          println("exception way.")          return // 结束线程        }        if (interrupted()) {          // clean work          return        }        count++        if (count % 100_000_000 == 0) {          println(count)        }        if (count % 1_000_000_000 == 0) {          break        }      }      println("I'm done.")    }  }.apply { start() }  Thread.sleep(100)  thread.interrupt()}