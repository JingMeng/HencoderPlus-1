package com.hsicen.a05_cooperateimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.Semaphoreimport kotlinx.coroutines.sync.withLockimport java.util.concurrent.atomic.AtomicIntegerimport kotlin.concurrent.threadimport kotlin.coroutines.EmptyCoroutineContext/******====== 67.互斥锁和共享变量 ======******//** * 1.Synchronized 方法 * 2.Synchronized(lock) 代码块 * 3.Lock 代码块 * 4.Mutex 代码块(不会阻塞线程) * 5.Semaphore 信号量，可以被多个线程持有的锁 *      acquire() 获取锁 *      release() 释放锁 * * 6.wait() == notify()/notifyAll() * 7.AtomicXXX  CopyOnWriteArrayList  Volatile  Transient */fun main(): Unit = runBlocking {    test6()    delay(5000)}private fun test1() {    val lock = Any()    var num = 0    val increase = thread {        repeat(1_000) {            synchronized(lock) {                num++            }        }    }    val decrease = thread {        repeat(1_000) {            synchronized(lock) {                num--            }        }    }    increase.join()    decrease.join()    println("result= $num")}private fun test2() {    val num = AtomicInteger(0)    val increase = thread {        repeat(1_000_000) {            num.incrementAndGet()        }    }    val decrease = thread {        repeat(1_000_000) {            num.decrementAndGet()        }    }    increase.join()    decrease.join()    println("result= ${num.get()}")}private suspend fun test3() {    val scope = CoroutineScope(EmptyCoroutineContext)    var num = 0    val increase = scope.launch {        repeat(1000_000_000) {            num++        }    }    val decrease = scope.launch {        repeat(1000_000_000) {            num--        }    }    increase.join()    decrease.join()    println("result= $num")}private suspend fun test4() {    val scope = CoroutineScope(EmptyCoroutineContext)    val lock = Any()    var num = 0    val increase = scope.launch(Dispatchers.IO) {        repeat(1_000_000_000) {            synchronized(lock) {                num++            }        }    }    val decrease = scope.launch(Dispatchers.IO) {        repeat(1_000_000_000) {            synchronized(lock) {                num--            }        }    }    increase.join()    decrease.join()    println("result= $num")}private suspend fun test5() {    val scope = CoroutineScope(EmptyCoroutineContext)    val lock = Mutex()    var num = 0    val increase = scope.launch(Dispatchers.IO) {        repeat(1_000_000) {            lock.withLock {                num++            }        }    }    val decrease = scope.launch(Dispatchers.IO) {        repeat(1_000_000) {            lock.withLock {                num--            }        }    }    increase.join()    decrease.join()    println("result= $num")}private suspend fun test6() {    val scope = CoroutineScope(EmptyCoroutineContext)    val lock = Semaphore(2)    var num = 0    val increase = scope.launch(Dispatchers.IO) {        repeat(1_000_000) {            lock.acquire()            num++            lock.release()        }    }    val decrease = scope.launch(Dispatchers.IO) {        repeat(1_000_000) {            lock.acquire()            num--            lock.release()        }    }    increase.join()    decrease.join()    println("result= $num")}