package com.hsicen.a04_channelflowimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.awaitCloseimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.asFlowimport kotlinx.coroutines.flow.callbackFlowimport kotlinx.coroutines.flow.channelFlowimport kotlinx.coroutines.flow.consumeAsFlowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.flow.receiveAsFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.withContext/******====== 41.Flow 的收集 ======******//** * Flow：collect *  1.flow 产生数据时不允许切换协程，简化开发 *  2.flow 产生数据的协程环境为 collect 时所在的协程环境 *  3.flowOn()/launchIn() 可以统一指定产生数据时所在的协程环境 *  4.如果要分别指定生产的每个数据的协程环境，直接使用[channelFlow] *  5.flow.collectIndexed，flow.collectLatest， */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()}private suspend fun test1() = coroutineScope {    val flow1 = flowOf(1)    val flow2 = listOf(1, 2, 3, 4).asFlow()    val flow3 = setOf(1, 2, 3, 4).asFlow()    val flow4 = sequenceOf(1, 2, 3, 4).asFlow()    // Channel 生产和接收是独立的    val channel = Channel<Int>()    val flow5 = channel.consumeAsFlow() // 只能被订阅一次    val flow6 = channel.receiveAsFlow() // 可以被订阅多次，多个订阅瓜分 channel 产生的数据    // 只有在调用 collect 的时候才会创建 channel，开始生产数据；    // 多次 collect 调用，会创建多个channel    // 可以启动子协程，切换线程环境    // 可以和传统的回调式 API 对接    val flow7 = channelFlow {        withContext(Dispatchers.IO) {            delay(200)            send(1)        }        send(2)        launch {            delay(500)            send(3)        }        awaitClose()// 等待协程结束    }    // 使用 channelFlow 实现，内部强制调用 awaitClose，    // suspendCancellableCoroutine 单次的回调 API 对接    // callbackFlow 多次的回调 API 对接    val flow8 = callbackFlow<Int> { }    launch {        flow7.flowOn(Dispatchers.Default)            .collect {                println(it)            }    }    // 等价于 launch { flow.collect { println(it) } }    flow8.onEach {        println(it)    }.launchIn(this)}