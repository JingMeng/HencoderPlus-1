package com.hsicen.a04_channelflowimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.withContext/******====== 39.Flow 的工作原理与应用场景 ======******//** * Flow：协程版的 Sequence，支持挂起函数的数据流 *  1.collect 是把 flow 中的代码块移动到 collect 中来执行的 *  2.不允许在发送数据的时候切换 CoroutineContext *  3.flow 中保存的是生产逻辑，在 collect 的时候执行这套生产逻辑(flow中的代码) *  4. * * 原理总结： *  Channel: hot(没收集数据的时候也可以生产数据)，数据的生产与是否接收无关，数据的生产是独立的 *  Flow: cold(开始收集数据的时候才开始生产数据)，数据要在接收时才会生产，保存的是生产规则 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test2()}private suspend fun test1() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    // 惰性集合(支持协程)    val nums = flow {        emit(loadData())        emit(loadData())        emit(loadData())        emit(loadData())    }    launch {        nums.flowOn(Dispatchers.IO)            .collect {                withContext(Dispatchers.Default) {                    println("Flow1: $it")                }            }    }    launch {        nums.collect {            println("Flow2: $it")        }    }}private suspend fun test2() = coroutineScope {    launch {        showWeather(weatherFlow)    }    println("after showWeather")}private val weatherFlow = flow {    while (true) {        emit(fetchWeather())    }}private suspend fun showWeather(weather: Flow<String>) {    weather.collect {        println("Now(${System.currentTimeMillis() / 1000}) weather is: $it")    }}private suspend fun fetchWeather() =    withContext(Dispatchers.IO) {        delay(5000)        "Sunny Cloudy Raining Snowing Foggy ..."    }