package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.currentCoroutineContextimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.launchimport kotlinx.coroutines.plusimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 57.flowOn 操作符 ======******//** * flowOn操作符：切换上游Flow的线程环境 *  1.作用和 catch 类似，只管上游的Flow * *  2.withContext 包裹住 emit 切换协程，会导致 collect 的协程环境也被切换 * *  3.flowOn 是针对整个操作符进行的切换，具体到某个代码块的切换只能用 withContext * *  4.catch 操作符和 try-catch 代码块 与 flowOn 操作符和 withContext 代码块 作用类似 * *  5.每个 flowOn 操作符只管它上游的 Flow 的线程环境， *    那最后的代码的线程环境由启动 flow 的线程环境管理(collect的调用位置) * *  6.官方推荐做法是将 collect 的代码块移动到 onEach 操作符中， *    然后在 onEach 操作符下游加一个 flowOn 操作符来切换线程环境(需要调用 collect) *    或者在 onEach 操作符下游加一个 launchIn 操作符来切换线程环境(不需要调用 collect) * *  7.多个连续调用的 flowOn 操作符只有第一个 flowOn 操作符会创建新的 Flow， *    后面的 flowOn 操作符会复用前面的 Flow，只是对 CoroutineContext 进行修改， *    CoroutineContext 的加减规则是：后调用的+先调用的，+号右边替代+号左边的值 * *  8. */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test2()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        println("Flow1 emit：${currentCoroutineContext()}")        emit(0)        emit(1)        emit(2)        emit(3)        emit(4)        emit(5)        emit(6)    }.map {        println("Flow1 map1：${currentCoroutineContext()}")        it    }.flowOn(Dispatchers.IO)    scope.launch {        flow1.map {            println("Flow1 map2：${currentCoroutineContext()}")        }.collect {            println("Flow1 collect(${currentCoroutineContext()}): $it")        }    }    flow1.onEach {        println("Flow2 onEach(${currentCoroutineContext()}): $it")    }.launchIn(scope + Dispatchers.IO)}private fun test2() {    // fuse    // 多个连续调用的 flowOn 会进行融合    // CoroutineContext 相加    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        println("Flow1 emit：${currentCoroutineContext()}")        emit(0)        emit(1)    }    // 多个连续的 flowOn 调用，只有第一个flowOn会创建Flow    // 融合规则：后调用的+先调用的，+号右边替代+号左边的值    // Dispatchers.Unconfined + Dispatchers.Default = Dispatchers.Default    // Dispatchers.Default + Dispatchers.IO = Dispatchers.IO    flow1        .flowOn(Dispatchers.IO) // 只有第一个起作用        .flowOn(Dispatchers.Default)        .flowOn(Dispatchers.Unconfined)        .onEach {            println("Flow2 onEach(${currentCoroutineContext()}): $it")        }.launchIn(scope + Dispatchers.Default) // 管上游的的操作符线程环境}