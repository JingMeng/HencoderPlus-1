package com.hsicen.a04_channelflowimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.ObsoleteCoroutinesApiimport kotlinx.coroutines.channels.BufferOverflowimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.Channel.Factory.CONFLATEDimport kotlinx.coroutines.channels.actorimport kotlinx.coroutines.channels.produceimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlocking/******====== 37.把 SendChannel 暴露出来 ======******//** * Channel：协程之间传递数据的工具 */fun main(): Unit = runBlocking {    // StateFlow  状态订阅    // ShareFlow  事件订阅    // Flow       数据流    test1()}private suspend fun test1() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    // 1.创建 Channel    val channel = Channel<String>(CONFLATED, BufferOverflow.SUSPEND) {        println("未接收的数据：$it")    }    // 2.发送数据    launch {        while (isActive) {            channel.send(loadData())        }    }    // 3.接收数据    launch {        for (data in channel) {            println(data)        }    }    channel.cancel()}@OptIn(ExperimentalCoroutinesApi::class)private suspend fun test2() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    // 1.创建Channel + 暴露出 ReceiveChannel    val receiveChannel = produce {        while (isActive) {            send(loadData())        }    }    // 2.接收数据    launch {        for (data in receiveChannel) {            println(data)        }    }}@OptIn(ObsoleteCoroutinesApi::class)private suspend fun test3() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    // 1.创建Channel + 暴露出 SendChannel    val sendChannel = actor<String> {        for (data in this) {            println(data)        }    }    // 发送数据    launch {        while (isActive) {            sendChannel.send(loadData())        }    }}