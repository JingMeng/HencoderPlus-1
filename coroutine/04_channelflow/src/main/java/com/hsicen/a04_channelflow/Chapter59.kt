package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flattenConcatimport kotlinx.coroutines.flow.flattenMergeimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.mergeimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 59.多个Flow的合并 ======******//** * buffer系列操作符：缓冲功能（ChannelFlow底层支撑） *  1.flowOn 操作符 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test5()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3)    val flow2 = flowOf(4, 5, 6)    val mergeFlow = merge(flow1, flow2)    mergeFlow.onEach {        println("Flow1: $it")    }.launchIn(scope)}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val mergeFlow = merge(flow1, flow2)    mergeFlow.onEach {        println("Flow2: $it")    }.launchIn(scope)}private fun test3() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val listFlow = listOf(flow1, flow2)    val mergeFlow = listFlow.merge()    mergeFlow.onEach {        println("Flow3: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test4() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    // 展开、合并    val flowFlow = flowOf(flow1, flow2)    val mergeFlow = flowFlow.flattenMerge()    mergeFlow.onEach {        println("Flow4: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test5() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val flowFlow = flowOf(flow2, flow1)    val mergeFlow = flowFlow.flattenConcat()    mergeFlow.onEach {        println("Flow5: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test6() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val flowFlow = flowOf(flow1, flow2)    val mergeFlow = flowFlow.flattenMerge()    mergeFlow.onEach {        println("Flow6: $it")    }.launchIn(scope)}