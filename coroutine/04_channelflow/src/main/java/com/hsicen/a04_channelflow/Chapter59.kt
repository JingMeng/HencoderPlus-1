package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.asFlowimport kotlinx.coroutines.flow.combineimport kotlinx.coroutines.flow.flatMapConcatimport kotlinx.coroutines.flow.flattenConcatimport kotlinx.coroutines.flow.flattenMergeimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.mergeimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.flow.zipimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 59.多个Flow的合并 ======******//** * Flow的合并：多个Flow合并成一个Flow * *  方式1：直接展开 Flow *  1.merge(Iterable)：按照所有 Flow 元素的发送顺序合并(同时收集) *  2.flattenMerge(Flow)：按照所有 Flow 元素的发送顺序合并(同时收集) *  3.flattenConcat(Flow)：按照每个 Flow 的顺序合并(单独收集，收集完一个再收集另一个) *  4.flatMapConcat(Flow): map + flattenConcat *  5.flatMapMerge(Flow): map + flattenMerge *  6.flatMapLatest(Flow): 收集最新的Flow * * *  方式2：将Flow合并后形成新的Flow *  7.combine(Flow)：同时收集多个Flow，将每个Flow最新的一条数据进行合并(会使用重复元素) *  8.zip(Flow)：同时收集多个Flow，将每个Flow的数据成对进行合并(不会使用重复元素) *  9.combineTransform(Flow)：不会主动发送 combine 后的数据，需要手动调用 emit 发送数据 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test10()    delay(5000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3)    val flow2 = flowOf(4, 5, 6)    //合并规则1：按照每个Flow发送顺序合并    val mergeFlow = merge(flow1, flow2)    mergeFlow.onEach {        println("Flow1: $it")    }.launchIn(scope)}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    //合并规则1：按照每个Flow发送顺序合并    val mergeFlow = merge(flow1, flow2)    mergeFlow.onEach {        println("Flow2: $it")    }.launchIn(scope)}private fun test3() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val listFlow = listOf(flow1, flow2)    val mergeFlow = listFlow.merge()    mergeFlow.onEach {        println("Flow3: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test4() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(100)        emit(1)        delay(100)        emit(2)        delay(100)        emit(3)    }    val flow2 = flow {        delay(200)        emit(4)        delay(200)        emit(5)        delay(200)        emit(6)    }    // 展开、合并    val flowFlow = flowOf(flow1, flow2)    val mergeFlow = flowFlow.flattenMerge()    mergeFlow.onEach {        println("Flow4: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test5() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val flowFlow = flowOf(flow2, flow1)    val mergeFlow = flowFlow.flattenConcat()    mergeFlow.onEach {        println("Flow5: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test6() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    val flowFlow = flowOf(flow1, flow2)    val mergeFlow = flowFlow.flattenMerge()    mergeFlow.onEach {        println("Flow6: $it")    }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test7() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val mapFlow = flow1.map { from ->        (1..from)            .asFlow()            .map { "$from -> $it" }    }    mapFlow.flattenConcat()        .onEach {            println("Flow7: $it")        }.launchIn(scope)}@OptIn(ExperimentalCoroutinesApi::class)private fun test8() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val mapFlow = flow1.flatMapConcat { from ->        (1..from)            .asFlow()            .map { "$from -> $it" }    }    mapFlow.onEach {        println("Flow8: $it")    }.launchIn(scope)}private fun test9() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)    }    flow1.combine(flow2) { a, b ->        "$a - $b"    }.onEach {        println("Flow9: $it")    }.launchIn(scope)    combine(flow1, flow2) { a, b ->        "$a - $b"    }.onEach {        println("Flow10: $it")    }.launchIn(scope)}private fun test10() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        delay(200)        emit(1)        delay(200)        emit(2)        delay(200)        emit(3)    }    val flow2 = flow {        delay(250)        emit(4)        delay(250)        emit(5)        delay(250)        emit(6)        delay(250)        emit(7)    }    flow1.zip(flow2) { a, b ->        "$a - $b"    }.onEach {        println("Flow10: $it")    }.launchIn(scope)}