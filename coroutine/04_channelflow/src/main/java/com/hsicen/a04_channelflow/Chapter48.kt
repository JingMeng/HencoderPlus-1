package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.transformimport kotlinx.coroutines.flow.transformLatestimport kotlinx.coroutines.flow.transformWhileimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 48.Flow 的 transform 操作符 ======******/fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}@OptIn(ExperimentalCoroutinesApi::class)private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3, 4, 5)    val flow2 = flowOf(1, 2, 3, 4, 5)    val flow3 = flow {        delay(500)        emit(1)        delay(500)        emit(2)        delay(500)        emit(3)        delay(500)        emit(4)        delay(500)        emit(5)    }    // transform 更加底层的 map    // 需要手动调用 emit 发送数据    scope.launch {        flow1.transform {            if (it % 2 == 0) {                emit(it + 1)            } else {                emit("哈哈哈")            }        }.collect {            println("flow1: $it")        }    }    // transformWhile(Boolean) = transform + takeWhile    // 遇到 true 就继续，一旦遇到false，就掐断，即使后续有true也不会下发    scope.launch {        flow2.transformWhile {            emit(it)            it <= 3        }.collect {            println("flow2：$it")        }    }    //transformLatest = mapLatest    scope.launch {        flow3.transformLatest {            delay(600)            emit(it)        }.collect {            println("flow3: $it")        }    }}