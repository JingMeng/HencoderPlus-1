package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.foldimport kotlinx.coroutines.flow.reduceimport kotlinx.coroutines.flow.runningFoldimport kotlinx.coroutines.flow.runningReduceimport kotlinx.coroutines.flow.scanimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 50.Flow 的 reduce/fold 操作符 ======******/fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3, 4, 5)    val flow2 = flowOf(1, 2, 3, 4, 5)    val flow3 = flowOf(1, 2, 3, 4, 5)    val flow4 = flowOf(1, 2, 3, 4, 5)    val flow5 = flowOf(1, 2, 3, 4, 5)    val list1 = listOf(1, 2, 3, 4, 5)    val list2 = listOf(1, 2, 3, 4, 5)    val list3 = listOf(1, 2, 3, 4, 5)    val list4 = listOf(1, 2, 3, 4, 5)    // 将所有元素融合在一起，融合类型不变    list1.reduce { acc, i ->        acc + i    }.let {        println("list1: $it")    }    // 返回一个新的List    list2.runningReduce { acc, i ->        acc + i // 当前项的值 + 前面几项的总值    }.let {        println("list2: $it")    }    // fold 折叠    // 和 reduce 功能一致，但是 fold 允许提供一个初始值    // 初始值的类型可以和 list 中的类型不一致    // 初始值的类型 = 最终的返回值类型    list3.fold("ha") { acc, i ->        "$acc - $i"    }.let {        println("list3: $it")    }    // runningFold 返回一个新的集合    list4.runningFold("ha") { acc, i ->        "$acc - $i"    }.let {        println("list4: $it")    }    // reduce 的结果不是一个 Flow 对象，会直接启动 collect，是一个挂起函数    // terminal operator    scope.launch {        flow1.reduce { accumulator, value ->            accumulator + value        }.let {            println("flow1: $it")        }    }    // runningReduce    // 不会直接启动 collect 操作    scope.launch {        flow2.runningReduce { accumulator, value ->            accumulator + value        }.collect {            println("flow2: $it")        }    }    // fold    scope.launch {        flow3.fold("ha") { acc, value ->            "$acc - $value"        }.let {            println("flow3: $it")        }    }    // runningFold    scope.launch {        flow4.runningFold("ha") { acc, value ->            "$acc - $value"        }.collect {            println("flow4: $it")        }    }    // scan    // 和 runningFold 作用一致    scope.launch {        flow5.scan("ha") { acc, value ->            "$acc - $value"        }.collect {            println("flow5: $it")        }    }}