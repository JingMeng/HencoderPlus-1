package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.retryimport kotlinx.coroutines.flow.retryWhenimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 55.retry/retryWhen 操作符 ======******//** * 提供重试功能： *  1.retry 操作符，可以捕获到上游的异常，进而重启上游的Flow(重新调用上游Flow的collect) *  2.retryWhen 作用和 retry 一致，会回调当前重试的次数 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test2()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        emit(0)        emit(1)        emit(2)        emit(3)        emit(4)        emit(5)        emit(6)    }.map {        if (it == 3) {            throw IllegalArgumentException("Error number.")        }        it    }.retry(3) {        it !is IllegalArgumentException // 判断为 true 时再 retry    }.catch {        println("Throwable in catch: $it")        emit(-1)    }    scope.launch {        flow1.collect {            println("flow1: $it")        }    }}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        emit(0)        emit(1)        emit(2)        emit(3)        emit(4)        emit(5)        emit(6)    }.map {        if (it == 3) {            throw IllegalArgumentException("Error number.")        }        it    }.retryWhen { cause, attempt ->        cause is IllegalArgumentException && attempt < 3    }.catch {        println("Throwable in catch: $it")        emit(-1)    }    scope.launch {        flow1.collect {            println("flow1: $it")        }    }}