package com.hsicen.a04_channelflowimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.cancelimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.awaitCloseimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.asFlowimport kotlinx.coroutines.flow.callbackFlowimport kotlinx.coroutines.flow.channelFlowimport kotlinx.coroutines.flow.consumeAsFlowimport kotlinx.coroutines.flow.filterimport kotlinx.coroutines.flow.filterIsInstanceimport kotlinx.coroutines.flow.filterNotimport kotlinx.coroutines.flow.filterNotNullimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.flow.receiveAsFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.withContext/******====== 42.Flow 的 filter 操作符 ======******//** * Flow：operator */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()}private suspend fun test1() = coroutineScope {    val flow1 = flowOf(1, 2, 3, 4, 5, 6, 7, 8, 9)    val flow2 = listOf(1, 2, 3, 4, "hello").asFlow()    val flow3 = setOf(1, 2, 3, 4, listOf(1, 2), listOf("hello")).asFlow()    val flow4 = sequenceOf(1, 2, 3, 4, "hello").asFlow()    // Channel 生产和接收是独立的    val channel = Channel<Int>()    val flow5 = channel.consumeAsFlow() // 只能被订阅一次    val flow6 = channel.receiveAsFlow() // 可以被订阅多次，多个订阅瓜分 channel 产生的数据    // 只有在调用 collect 的时候才会创建 channel，开始生产数据；    // 多次 collect 调用，会创建多个channel    // 可以启动子协程，切换线程环境    // 可以和传统的回调式 API 对接    val flow7 = channelFlow {        withContext(Dispatchers.IO) {            delay(200)            send(1)        }        send(2)        launch {            delay(500)            send(3)        }        // awaitClose()// 等待协程结束    }    // 使用 channelFlow 实现，内部强制调用 awaitClose，    // suspendCancellableCoroutine 单次的回调 API 对接    // callbackFlow 多次的回调 API 对接    val flow8 = callbackFlow<Int> {        cancel()        awaitClose()    }    launch {        flow7.flowOn(Dispatchers.Default)            .collect {                println(it)            }    }    // 等价于 launch { flow.collect { println(it) } }    flow8.onEach {        println(it)    }.launchIn(this)    // 操作符 Operator    // 1.filter  会创建一个新的 flow，原来的 flow 不会改变    flow1.filter {        it % 2 == 0 // 符合条件的才发送到下游    }.collect {        println("filter: $it")    }    // 2.filterNot 会创建一个新的 flow，原来的 flow 不会改变    flow1.filterNot {        it % 2 == 0 // 不符合条件的才发送到下游    }.collect {        println("filterNot: $it")    }    // 3.filterNotNull    flow1.filterNotNull()        .collect {            println("filterNotNull: $it")        }    // 4.filterIsInstance 注意泛型擦除的情况    flow2.filterIsInstance<Int>()        .collect {            println("filterIsInstance: $it")        }    flow4.filterIsInstance(String::class)        .collect {            println("filterIsInstance: $it")        }    flow3.filterIsInstance<List<String>>() // 泛型擦除的情况，无法匹配；还是需要使用最原始的 filter        .collect {            println("filterIsInstance(List<String>): $it")        }}