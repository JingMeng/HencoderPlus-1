package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.cancelimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.SharingStartedimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.shareInimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 62.shareIn操作符 ======******//** * shareIn： * 参数 *  1.scope：shareIn启动所在的协程 *  2.started：shareIn启动的策略 *      1.Eagerly：立即启动上游的数据生产流程(调用上游的collect) *      2.Lazily：第一次调用collect时启动上游的数据生产流程(调用上游的collect) *      3.WhileSubscribed：一种更复杂的Lazily策略 *        在Lazily的策略上，如果当前Flow的所有订阅都结束了，就会停止数据的生产流程； *        在停止数据生产流程后，如果又有新的订阅者，就会重新启动上游的数据生产流程 *        （1）stopTimeoutMillis：延时结束订阅的时间(在这时间内不结束，不重启) *        （2）replayExpirationMillis：缓存过期时间，超过该时间，缓存的数据就会清除 * *  3.replay：缓冲+缓存 功能 *      1.缓冲：上游生产速度大于下游消费速度 *      2.缓存：在缓冲的前提下，不管数据是否被消费，都会缓存指定数量数据，用于发送给新的订阅者 * *  ShareFlow订阅流程的结束： *   1.collect不会随着上游的结束而结束，永远不会返回 *   2.会随着外部协程抛异常的取消而结束 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test3()    delay(5000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        repeat(10) {            delay(100)            println("emit: $it")            emit(it)        }    }    val shareFlow = flow1.shareIn(scope, SharingStarted.Eagerly, replay = 1)    scope.launch {        delay(600)        shareFlow.collect {            println("collect: $it")        }    }}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        repeat(5) {            delay(100)            println("emit: $it")            emit(it)        }    }    val shareFlow = flow1.shareIn(scope, SharingStarted.Eagerly, replay = 1)    scope.launch {        delay(450)        shareFlow.collect {            println("collect1: $it")        }    }    scope.launch {        delay(550)        shareFlow.collect {            println("collect2: $it")        }    }    // 会收到缓存的数据    scope.launch {        delay(1000)        shareFlow.collect {            println("collect3: $it")        }    }}private fun test3() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        repeat(5) {            delay(100)            println("emit: $it")            emit(it)        }    }    val shareFlow = flow1.shareIn(scope, SharingStarted.WhileSubscribed(), replay = 1)    scope.launch {        val parent = this        launch {            delay(1800)            parent.cancel()        }        shareFlow.collect {            println("collect1: $it")        }    }    scope.launch {        delay(2000)        shareFlow.collect {            println("collect2: $it")        }    }}