package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.bufferimport kotlinx.coroutines.flow.conflateimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.onEachimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 58.buffer 系列操作符 ======******//** * buffer系列操作符：缓冲功能（ChannelFlow底层支撑） *  1.flowOn 操作符会默认打开缓冲功能，不支持缓冲配置 * *  2.buffer 操作符会创建新的 Flow，可以配置缓冲区大小和溢出策略 *      capacity：缓冲区大小 *      onBufferOverflow：缓冲溢出策略 *      这两个参数的作用与ChannelFlow的一致 * *  3.flowOn和buffer的缓冲功能都是由底层的ChannelFlow实现的 * *  4.buffer 的进行融合，右边优先原则(后调用) *      第二个参数(默认SUSPEND)： *          （1）如果当前(右边buffer)参数不是SUSPEND，右边的 buffer 就会完全覆盖左边 buffer 的参数值(缓冲大小+缓冲溢出策略) *          （2）如果当前(右边buffer)参数是SUSPEND，缓冲策略会沿用左边 buffer 的，缓冲大小会进行融合 * *      第一个参数：缓冲区大小 *          （1）如果两个都没填写缓冲大小，就会使用默认大小为融合后的大小 *          （2）如果一个填写了值，另一个没填写值，就会使用填写的值作为融合后的大小 *          （3）如果都填写了大小，就会将两个值相加作为融合后的大小 * * conflate： *  1.只缓冲最新的一条数据 *  2.等同于 buffer(CONFLATED) *  3.collectLatest() = mapLatest()  转换最新的 *                  + buffer(0)      缓冲大小为0 *                  + collect()      收集数据 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test4()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val start = System.currentTimeMillis()    val flow1 = flow {        repeat(5) {            emit(it)            println("Emit: $it ${System.currentTimeMillis() - start}ms")        }    }    flow1.map { it * 2 }        .map { it + 1 }        .onEach {            delay(1000)            println("Flow1: $it")        }.launchIn(scope)}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val start = System.currentTimeMillis()    val flow1 = flow {        repeat(5) {            emit(it)            println("Emit: $it ${System.currentTimeMillis() - start}ms")        }    }.flowOn(Dispatchers.IO)    flow1.map { it * 2 }        .map { it + 1 }        .onEach {            delay(1000)            println("Flow1: $it")        }.launchIn(scope)}private fun test3() {    // buffer 的融合    val scope = CoroutineScope(EmptyCoroutineContext)    val start = System.currentTimeMillis()    val flow1 = flow {        repeat(5) {            emit(it)            println("Emit: $it ${System.currentTimeMillis() - start}ms")        }    }.flowOn(Dispatchers.IO)        .buffer(2)        .buffer(1)    flow1.map { it * 2 }        .map { it + 1 }        .onEach {            delay(1000)            println("Flow1: $it")        }.launchIn(scope)}private fun test4() {    // conflated    val scope = CoroutineScope(EmptyCoroutineContext)    val start = System.currentTimeMillis()    val flow1 = flow {        repeat(5) {            emit(it)            println("Emit: $it ${System.currentTimeMillis() - start}ms")        }    }.flowOn(Dispatchers.IO)        .conflate()    flow1.map { it * 2 }        .map { it + 1 }        .onEach {            delay(1000)            println("Flow1: $it")        }.launchIn(scope)}