package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineExceptionHandlerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.FlowPreviewimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.sampleimport kotlinx.coroutines.flow.timeoutimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContextimport kotlin.time.Duration.Companion.milliseconds/******====== 45.Flow 的 timeout/sample/debounce 操作符 ======******//** * Flow：operator */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}@OptIn(FlowPreview::class)private fun test1() {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    val eh = CoroutineExceptionHandler { _, exception ->        println("Caught $exception")    }    val scope = CoroutineScope(EmptyCoroutineContext + eh)    val flow1 = flowOf(1, 2, 3, 4, 5, 1, 2, 3, 6, 6, 7, 8, 9, 10)    val flow2 = flowOf("Hsicen", "hsicen", "HsIcen", "hsiceni")    val flow3 = flow {        emit(1)        delay(200)        emit(2)        delay(100)        emit(3)    }    // timeout 会重新计时    // 从 collect 开始即使，超过指定时间没有收到数据时，就抛出 TimeoutCancellationException，结束流程    // 如果在指定时间内收到了数据，就重置时间，开始下一条数据的超时记时    scope.launch {        flow3.timeout(150.milliseconds)            .catch {                println("接收出错：$it")            }.collect {                println(it)            }    }    // sample 固定时间点刷新，每次刷新只取最新数据    scope.launch {        flow3.sample(150.milliseconds)            .catch {                println("接收出错：$it")            }.collect {                println(it)            }    }}