package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineExceptionHandlerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.FlowPreviewimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.sampleimport kotlinx.coroutines.flow.timeoutimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContextimport kotlin.time.Duration.Companion.seconds/******====== 45.Flow 的 timeout/sample/debounce 操作符 ======******//** * Flow：operator */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}@OptIn(FlowPreview::class)private fun test1() {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    val eh = CoroutineExceptionHandler { _, exception ->        println("Caught $exception")    }    val scope = CoroutineScope(EmptyCoroutineContext + eh)    val flow1 = flowOf(1, 2, 3, 4, 5, 1, 2, 3, 6, 6, 7, 8, 9, 10)    val flow2 = flowOf("Hsicen", "hsicen", "HsIcen", "hsiceni")    val flow3 = flow {        delay(500)        emit(1)        delay(800)        emit(2)        delay(900)        emit(3)    }    val flow4 = flow {        emit(0)        delay(500)        emit(1)        delay(800)        emit(2)        delay(900)        emit(3)        delay(1000)    }    val flow5 = flow {        emit(0)        delay(500)        emit(1)        delay(800)        emit(2)        delay(900)        emit(3)        delay(1000)    }    // timeout 会重新计时    // 从调用 collect 时开始计时，超过指定时间没有收到数据时，就抛出 TimeoutCancellationException，结束流程    // 如果在指定时间内收到了数据，就重置时间，开始下一条数据的超时记时    scope.launch {        flow3.timeout(1.seconds)            .collect {                println("flow3 接收：$it")            }    }    // sample 适用于定时刷新场景    // 固定时间点刷新，每次刷新只取最新数据    scope.launch {        flow4.sample(1.seconds)            .catch {                println("flow4接收出错：$it")            }.collect {                println("flow4 接收：$it")            }    }    // debounce  适用于搜索提示场景    // 去抖动，防抖；一段时间内的事件只取最新值    // 在这一段事件内只要有新值都会重新计时    // 只要这段时间内没有新值时，才会传递记录的最新值    scope.launch {        flow5.timeout(1.seconds)            .collect {                println("flow5 接收：$it")            }    }}