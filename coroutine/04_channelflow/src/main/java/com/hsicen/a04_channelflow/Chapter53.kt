package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 53.try/catch 和 Flow 的异常可见性 ======******//** * 不要使用 try/catch 包裹住 emit 函数，否者会吞掉 collect 的异常捕获 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test2()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        try {            emit(1)            emit(2)            emit(3)            emit(0)            emit(4)            emit(5)        } catch (t: Throwable) {            println("Throwable in emit: $t")        }    }    // Exception Transparency    // 1.不要用 try-catch 包裹 emit 代码块(防止吞异常)    scope.launch {        try {            flow1.collect {                it / it            }        } catch (t: Throwable) {            println("Throwable in collect: $t")        }    }}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        try {            emit(1)            emit(2)            emit(3)            emit(0)            emit(4)            emit(5)        } catch (t: Throwable) {            println("Throwable in emit: $t")        }    }.map {        // 1.下游操作符的异常会经过 map 代码块么？==> 不会        // 2.map 的代码块里如果抛出异常，这个异常会走向那里？ ==> 会被上游的 emit 拦截        it / it    }    // Exception Transparency    // 1.不要用 try-catch 包裹 emit 代码块(防止吞异常)    scope.launch {        try {            flow1.collect {                it / it            }        } catch (t: Throwable) {            println("Throwable in collect: $t")        }    }}