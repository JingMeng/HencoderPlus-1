package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.SharingStartedimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.shareInimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 61.ShareFlow的效果和适用场景 ======******//** * ShareFlow： * shareIn 和 launchIn 的区别 *  1.launchIn会立即启动 collect，shareIn是通过传入的参数来决定何时启动collect *  2.shareIn会返回一个新的Flow(SharedFlow),来转发原来Flow的数据 *  3.ShareFlow的数据发送流程和收集流程是分开的 *  4.ShareFlow数据的生产流程只会进行一次，但是可以进行多次的collect *  5.ShareFlow多次的collect，每个collect只会收集最新的数据 * * shareIn使用场景： *  1.数据源共享，同一个数据流 *  2.数据生产提前启动(shareIn开始生产) *  3.数据生产和数据收集流程是分开的(根本原因) *  4.会漏数据(因为生产和收集是分开的) */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(5000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        repeat(5) {            delay(100)            println("emit: $it")            emit(it)        }    }    val shareFlow = flow1.shareIn(scope, SharingStarted.Eagerly)    scope.launch {        delay(150)        shareFlow.collect {            println("collect1: $it")        }    }    scope.launch {        delay(200)        shareFlow.collect {            println("collect2: $it")        }    }    scope.launch {        delay(400)        shareFlow.collect {            println("collect3: $it")        }    }}private fun test2() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        repeat(5) {            delay(100)            println("emit: $it")            emit(it)        }    }    val shareFlow = flow1.shareIn(scope, SharingStarted.Eagerly)    scope.launch {        delay(150)        flow1.collect {            println("collect1: $it")        }    }    scope.launch {        delay(200)        flow1.collect {            println("collect2: $it")        }    }    scope.launch {        delay(400)        flow1.collect {            println("collect3: $it")        }    }}