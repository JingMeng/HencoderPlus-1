package com.hsicen.a04_channelflowimport kotlinx.coroutines.channels.BufferOverflowimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.Channel.Factory.CONFLATEDimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlocking/******====== 36.Channel API 详解 ======******//** * Channel：协程之间传递数据的工具 *  capacity：设置缓冲大小(队列的尺寸)，缓冲溢出，挂起协程 *  onBufferOverflow：缓冲溢出的策略(挂起，丢弃) *  onUndeliveredElement：未发送的数据处理 * * 关闭： *  1. close()   从发送端关闭，不再发送数据(send) *      (1) 属于 SendChannel 的函数, isClosedForSend 默认为 false *      (2) 在 close 之后，isClosedForSend 标记为 true，不允许再调用 send 发送数据 *      (3) 在 close 之后调用 send，会抛出 ClosedSendChannelException，已经挂起的 send 函数不受影响 *      (4) 在 close 之后调用 receive，不受影响 *      (5) 在 close 之后，所有的元素都 receive 后，isClosedForReceive 会被标记为 true *  2. cancel()  从接收端关闭，不再需要新数据(receive) *      (1) 属于 ReceiveChannel 的函数, isClosedForReceive 默认为 false *      (2) 在 cancel 之后，isClosedForReceive 标记为 true，不再需要发送和接收数据 *      (3) 在 cancel 之后，发送和接收数据会抛出 CancellationException * * 非挂起函数：直接返回结果 *  trySend() *  tryReceive() * * 挂起函数： *  receiveCatching() = receive() + tryReceive() */fun main(): Unit = runBlocking {    // StateFlow  状态订阅    // ShareFlow  事件订阅    // Flow       数据流    test1()}private suspend fun test1() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    val channel = Channel<String>(CONFLATED, BufferOverflow.SUSPEND) {        println("未接收的数据：$it")    }    launch {        while (isActive) {            channel.send(loadData())        }    }    launch {        for (data in channel) {            println(data)        }    }    channel.cancel()}