package com.hsicen.a04_channelflowimport kotlinx.coroutines.channels.Channelimport kotlinx.coroutines.channels.Channel.Factory.BUFFEREDimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlocking/******====== 36.Channel API 详解 ======******//** * Channel：协程之间传递数据的工具 *  capacity：设置缓冲大小 *  onBufferOverflow：缓冲策略(挂起，丢弃) *  onUndeliveredElement：未发送的数据处理 * * 关闭： *  1. close()   从发送端关闭，不再发送数据(send) *  2. cancel()  从接收端关闭，不再需要新数据(receive) * *  trySend() *  tryReceive() */fun main(): Unit = runBlocking {    // StateFlow  状态订阅    // ShareFlow  事件订阅    // Flow       数据流    test1()}private suspend fun test1() = coroutineScope {    suspend fun loadData(): String {        delay(2000)        return "Content load from network. ${System.currentTimeMillis() / 1000}"    }    val channel = Channel<String>(BUFFERED)    launch {        while (isActive) {            channel.send(loadData())        }    }    launch {        for (data in channel) {            println(data)        }    }    channel.close()}