package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 54.catch 操作符 ======******//** * 1.catch 操作符可以捕获上游的异常，不会捕获下游的异常(emit代码块) * 2.不会捕获 CancellationException * 3.异常情况下后续流程的接管(收尾工作) */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}// 什么时候用 try-catch？// 在 flow 内部工作，处理数据生产过程中异常，处理异常过后可以继续数据的生产流程// 什么时候用 catch 操作符？// 在 flow 下游工作，发生异常后，不能继续 Flow 的数据生产流程// 能用 try-catch 尽量用 try-catch// 无法修改 Flow 生产代码时再使用 catch 操作符private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        emit(0)        emit(1)        emit(2)        emit(3)        emit(4)        emit(5)    }.map {        if (it == 3) {            throw IllegalArgumentException("Error number.")        }        it    }.catch {        println("Throwable in catch: $it")        emit(-1)    }    scope.launch {        flow1.collect {            println("flow1: $it")        }    }}