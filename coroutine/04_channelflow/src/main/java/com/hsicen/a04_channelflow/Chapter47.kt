package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.mapLatestimport kotlinx.coroutines.flow.mapNotNullimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 47.Flow 的 map 操作符 ======******/fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}@OptIn(ExperimentalCoroutinesApi::class)private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3, 4, 5)    val flow2 = flowOf(1, 2, null, 4, 5)    val flow3 = flow {        delay(100)        emit(1)        delay(100)        emit(2)        delay(100)        emit(3)    }    val flow4 = flowOf(1, 2, 3, 4, 5)    // map 映射操作    // 将原数据按照某种算法转换成另一个数据    scope.launch {        flow1.map {            it + 1        }.collect {            println("flow1: $it")        }    }    // map + filterNotNull    scope.launch {        flow2.mapNotNull {            it?.inc()        }.collect {            println("flow2: $it")        }    }    // mapLatest    // 只处理最新的数据    // 在数据处理过程中，这时候又来了一条新数据，    // 就会丢弃掉正在处理的这条数据，去处理这条最新的数据    scope.launch {        flow3.mapLatest {            delay(150)            it + 1        }.collect {            println("flow3: $it")        }    }}