package com.hsicen.a04_channelflowimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.asyncimport kotlinx.coroutines.channels.consumeEachimport kotlinx.coroutines.channels.produceimport kotlinx.coroutines.coroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.runBlocking/******====== 34.用 produce() 来提供跨协程的事件流 ======******//** * Channel：协程之间传递数据的工具 * */fun main(): Unit = runBlocking {    // StateFlow  状态订阅    // ShareFlow  事件订阅    // Flow       数据流    test2()}@OptIn(ExperimentalCoroutinesApi::class)private suspend fun test3() {    coroutineScope {        produce {            this.send("1")            this.send("2")            this.send("3")        }.consumeEach {            println("consume: $it")        }    }}private suspend fun test1() = coroutineScope {    val deferred1 = async {        delay(500)        "Content1"    }    val deferred2 = async {        delay(1500)        "Content2"    }    println("Result: ${deferred1.await()} ==> ${deferred2.await()}")}@OptIn(ExperimentalCoroutinesApi::class)private suspend fun test2() = coroutineScope {    produce {        while (isActive) {            val data = loadData()            send(data)        }    }.consumeEach {        println(it)    }}suspend fun loadData(): String {    delay(2000)    return "Content load from network. ${System.currentTimeMillis() / 1000}"}