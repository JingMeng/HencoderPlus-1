package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.onCompletionimport kotlinx.coroutines.flow.onEmptyimport kotlinx.coroutines.flow.onStartimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 56.onStart/onCompletion 操作符 ======******//** * 全流程监听操作符： *  1.开始onStart： *      （1）在 Flow 生产数据之前调用 *      （2）可以重复调用，后调用的会先执行 *      （3）包裹 emit 的 try-catch 不能捕获到 onStart 中的异常 *      （4）catch 操作符可以捕获到 onStart 中的异常 * *  2.完成onCompletion： *      （1）在 Flow 结束时调用(正常+异常结束) *      （2）不会拦截异常 * *  3.onEmpty *      (1) 在 Flow 正常结束并且没有发送过任何数据时调用 */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flow {        emit(0)        emit(1)        emit(2)        emit(3)        emit(4)        emit(5)        emit(6)    }.onStart {        println("onStart1")    }.onStart {        println("onStart2")    }.onCompletion {        println("onCompletion1: $it")    }.onCompletion {        println("onCompletion2: $it")    }.catch {        println("catch: $it")    }.onEmpty {        println("onEmpty")    }    scope.launch {        flow1.collect {            println("flow1: $it")        }    }}