package com.hsicen.a04_channelflowimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.dropimport kotlinx.coroutines.flow.dropWhileimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.flow.takeimport kotlinx.coroutines.flow.takeWhileimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingimport kotlin.coroutines.EmptyCoroutineContext/******====== 46.Flow 的 drop/take 操作符 ======******//** * Flow：operator */fun main(): Unit = runBlocking {    // Flow        数据流    // SharedFlow  事件订阅(一对多，跨协程)    // StateFlow   状态订阅    test1()    delay(10000)}private fun test1() {    val scope = CoroutineScope(EmptyCoroutineContext)    val flow1 = flowOf(1, 2, 3, 4, 5)    val flow2 = flowOf(1, 2, 3, 4, 5)    val flow3 = flowOf(1, 2, 3, 4, 5)    val flow4 = flowOf(1, 2, 3, 4, 5)    // drop(Int)    // 丢弃前 n 条数据    scope.launch {        flow1.drop(2) //丢弃前2条数据            .collect {                println("flow1: $it")            }    }    // dropWhile(Boolean)    // 丢弃满足指定条件的数据，    // 一旦条件不满足，数据下发，后续满足条件的数据也会继续下发    scope.launch {        flow2.dropWhile {            it % 2 != 0 // 满足指定条件的数据不下发        }.collect {            println("flow2: $it")        }    }    // take(Int)    // 下发前n条数据    scope.launch {        flow3.take(2)            .collect {                println("flow3: $it")            }    }    // takeWhile(Boolean)    // 下发满足指定条件的数据    // 一旦条不件满足，数据不下发，后续满足条件的数据也不会下发    scope.launch {        flow4.takeWhile {            it % 2 == 0 // 满足指定条件的数据下发        }.collect {            println("flow4: $it")        }    }}